<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Knowledge</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">EricLiu's Blog</a></li><li class="chapter-item expanded affix "><li class="part-title">深入理解计算机系统 (CSAPP)</li><li class="chapter-item expanded "><a href="深入理解计算机系统/信息的表示和处理.html"><strong aria-hidden="true">1.</strong> 信息的表示和处理</a></li><li class="chapter-item expanded "><a href="深入理解计算机系统/程序的机器级表示.html"><strong aria-hidden="true">2.</strong> 程序的机器级表示</a></li><li class="chapter-item expanded "><a href="深入理解计算机系统/优化程序性能.html"><strong aria-hidden="true">3.</strong> 优化程序性能</a></li><li class="chapter-item expanded "><a href="深入理解计算机系统/存储器层次结构.html"><strong aria-hidden="true">4.</strong> 存储器层次结构</a></li><li class="chapter-item expanded "><a href="深入理解计算机系统/链接.html"><strong aria-hidden="true">5.</strong> 链接</a></li><li class="chapter-item expanded affix "><li class="part-title">CS</li><li class="chapter-item expanded "><a href="CS/AsynchronyProgramming.html"><strong aria-hidden="true">6.</strong> 异步编程</a></li><li class="chapter-item expanded "><a href="CS/DesignPatterns.html"><strong aria-hidden="true">7.</strong> 设计模式</a></li><li class="chapter-item expanded affix "><li class="part-title">Swift语言参考</li><li class="chapter-item expanded "><a href="Swift/ReferenceManual/LexicalStructure.html"><strong aria-hidden="true">8.</strong> 词法结构</a></li><li class="chapter-item expanded "><a href="Swift/ReferenceManual/Types.html"><strong aria-hidden="true">9.</strong> 类型</a></li><li class="chapter-item expanded "><a href="Swift/ReferenceManual/Expressions.html"><strong aria-hidden="true">10.</strong> 表达式</a></li><li class="chapter-item expanded "><a href="Swift/ReferenceManual/Statements.html"><strong aria-hidden="true">11.</strong> 语句</a></li><li class="chapter-item expanded "><a href="Swift/ReferenceManual/Declarations.html"><strong aria-hidden="true">12.</strong> 声明</a></li><li class="chapter-item expanded "><a href="Swift/ReferenceManual/Attributes.html"><strong aria-hidden="true">13.</strong> 特性</a></li><li class="chapter-item expanded affix "><li class="part-title">Swift Evolution</li><li class="chapter-item expanded "><a href="Swift/Evolution/Swift5.6.html"><strong aria-hidden="true">14.</strong> Swift5.6</a></li><li class="chapter-item expanded affix "><li class="part-title">iOS</li><li class="chapter-item expanded "><a href="iOS/Data-structure.html"><strong aria-hidden="true">15.</strong> 数据结构</a></li><li class="chapter-item expanded "><a href="iOS/Algorithm.html"><strong aria-hidden="true">16.</strong> 算法</a></li><li class="chapter-item expanded "><a href="iOS/Swift.html"><strong aria-hidden="true">17.</strong> Swift</a></li><li class="chapter-item expanded "><a href="iOS/String.html"><strong aria-hidden="true">18.</strong> String</a></li><li class="chapter-item expanded "><a href="iOS/Foundation.html"><strong aria-hidden="true">19.</strong> Foundation</a></li><li class="chapter-item expanded "><a href="iOS/UIKit.html"><strong aria-hidden="true">20.</strong> UIKit</a></li><li class="chapter-item expanded "><a href="iOS/WebKit.html"><strong aria-hidden="true">21.</strong> WebKit</a></li><li class="chapter-item expanded "><a href="iOS/Memory-management.html"><strong aria-hidden="true">22.</strong> 内存管理</a></li><li class="chapter-item expanded "><a href="iOS/Network.html"><strong aria-hidden="true">23.</strong> 网络</a></li><li class="chapter-item expanded "><a href="iOS/Data-storage.html"><strong aria-hidden="true">24.</strong> 数据存储</a></li><li class="chapter-item expanded "><a href="iOS/Multi-thread.html"><strong aria-hidden="true">25.</strong> 多线程</a></li><li class="chapter-item expanded "><a href="iOS/Design-patterns.html"><strong aria-hidden="true">26.</strong> 设计模式</a></li><li class="chapter-item expanded "><a href="iOS/Concurrency.html"><strong aria-hidden="true">27.</strong> 并发编程</a></li><li class="chapter-item expanded "><a href="iOS/Alamofire.html"><strong aria-hidden="true">28.</strong> Alamofire</a></li><li class="chapter-item expanded "><a href="iOS/OC2Swift.html"><strong aria-hidden="true">29.</strong> Objective-C组件库用Swift转写的方法论</a></li><li class="chapter-item expanded "><a href="iOS/ApplicationExtensionUnavailable.html"><strong aria-hidden="true">30.</strong> 应用扩展不可用编译错误</a></li><li class="chapter-item expanded "><a href="iOS/UnsafePointer.html"><strong aria-hidden="true">31.</strong> Swift指针</a></li><li class="chapter-item expanded affix "><li class="part-title">Web</li><li class="chapter-item expanded "><a href="Web/CSS.html"><strong aria-hidden="true">32.</strong> CSS</a></li><li class="chapter-item expanded "><a href="Web/HTML.html"><strong aria-hidden="true">33.</strong> HTML</a></li><li class="chapter-item expanded "><a href="Web/JavaScript.html"><strong aria-hidden="true">34.</strong> JavaScript</a></li><li class="chapter-item expanded "><a href="Web/JavaScript.html"><strong aria-hidden="true">35.</strong> React</a></li><li class="chapter-item expanded "><a href="Web/Taro.html"><strong aria-hidden="true">36.</strong> Taro快速开始</a></li><li class="chapter-item expanded "><a href="Web/Vue.html"><strong aria-hidden="true">37.</strong> Vue</a></li><li class="chapter-item expanded "><a href="Web/http.html"><strong aria-hidden="true">38.</strong> http</a></li><li class="chapter-item expanded "><a href="Web/Performance-optimization.html"><strong aria-hidden="true">39.</strong> 性能优化</a></li><li class="chapter-item expanded affix "><li class="part-title">Books</li><li class="chapter-item expanded "><a href="Books/Swifter-SwiftTips.html"><strong aria-hidden="true">40.</strong> Swifter Swift必备Tips</a></li><li class="chapter-item expanded affix "><li class="part-title">Tools</li><li class="chapter-item expanded "><a href="Tools/SwiftToolChain.html"><strong aria-hidden="true">41.</strong> Swift工具链</a></li><li class="chapter-item expanded "><a href="Tools/Git.html"><strong aria-hidden="true">42.</strong> Git</a></li><li class="chapter-item expanded "><a href="Tools/DocC.html"><strong aria-hidden="true">43.</strong> DocC</a></li><li class="chapter-item expanded "><a href="Tools/Gitmoji.html"><strong aria-hidden="true">44.</strong> Gitmoji</a></li><li class="chapter-item expanded "><a href="Tools/UsefulWebsites.html"><strong aria-hidden="true">45.</strong> 有用的网站</a></li><li class="chapter-item expanded "><a href="Tools/mdbook.html"><strong aria-hidden="true">46.</strong> mdbook</a></li><li class="chapter-item expanded "><a href="Tools/Vuepress.html"><strong aria-hidden="true">47.</strong> Vuepress</a></li><li class="chapter-item expanded "><a href="Tools/Markdown.html"><strong aria-hidden="true">48.</strong> Markdown</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="swift-react-dart-go"><a class="header" href="#swift-react-dart-go">Swift React Dart Go</a></h1>
<h2 id="rust-python"><a class="header" href="#rust-python">Rust Python</a></h2>
<h2 id="dont-be-addicted-to-technology"><a class="header" href="#dont-be-addicted-to-technology">Don't be addicted to technology</a></h2>
<h2 id="products-are-more-important-than-tools-and-programming-languages"><a class="header" href="#products-are-more-important-than-tools-and-programming-languages">Products are more important than tools and programming languages</a></h2>
<h2 id="love-and-life-are-even-more-important"><a class="header" href="#love-and-life-are-even-more-important">Love💕 and life are even more important</a></h2>
<p><a href="https://github.com/ericliuhusky">GitHub</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="信息的表示和处理"><a class="header" href="#信息的表示和处理">信息的表示和处理</a></h1>
<h2 id="字节序"><a class="header" href="#字节序">字节序</a></h2>
<p>字节序 (Endianness) 面向 <strong>多字节数值类型</strong> (Int16, Int32, Int64) 定义</p>
<ul>
<li>小端(littleEndian): 多字节数值类型的数值低位存储在内存低位，小端易存取易计算，多用于存储</li>
<li>大端(bigEndian): 数值低位存储在内存高位，大端易阅读，多用于网络传输</li>
</ul>
<pre><code class="language-swift">// iOS字节序是小端
withUnsafeBytes(of: UInt32(0x01_02_03_04)) { p in
    p.forEach { byte in
        print(byte) // 4 3 2 1
    }
}

// 转为大端
withUnsafeBytes(of: UInt32(0x01_02_03_04).bigEndian) { p in
    p.forEach { byte in
        print(byte) // 1 2 3 4
    }
}
</code></pre>
<h2 id="整数表示"><a class="header" href="#整数表示">整数表示</a></h2>
<table><thead><tr><th>整数类型</th><th>十进制</th><th>二进制</th><th>原码</th><th>反码</th><th>补码</th><th>计算机中实际的记录</th></tr></thead><tbody>
<tr><td>Int</td><td>3</td><td>0011</td><td></td><td></td><td></td><td>0011</td></tr>
<tr><td>Int</td><td>-3</td><td>-0011</td><td>1011</td><td>1100</td><td>1101</td><td>1101</td></tr>
<tr><td>UInt</td><td>3</td><td>0011</td><td></td><td></td><td></td><td>0011</td></tr>
</tbody></table>
<pre><code class="language-swift">withUnsafeBytes(of: 3) { p in
    print(String(p[0], radix: 2)) // 00000011
}

withUnsafeBytes(of: -3) { p in
    print(String(p[0], radix: 2)) // 11111101
}
</code></pre>
<h2 id="浮点数表示"><a class="header" href="#浮点数表示">浮点数表示</a></h2>
<table><thead><tr><th>浮点数类型</th><th>十进制</th><th>二进制</th><th>科学计数</th><th>阶数</th><th>尾数</th><th>计算机中实际的记录</th></tr></thead><tbody>
<tr><td>Float</td><td>3.625</td><td>11.101</td><td>1.1101 * 2^1</td><td>1 + 01111111</td><td>1101</td><td>0100000001101</td></tr>
<tr><td>Float</td><td>-3.625</td><td>-11.101</td><td>-1.1101 * 2^1</td><td>1 + 01111111</td><td>1101</td><td>1100000001101</td></tr>
<tr><td>Double</td><td>3.625</td><td>11.101</td><td>1.1101 * 2^1</td><td>1 + 01111111111</td><td>1101</td><td>0100000000001101</td></tr>
<tr><td>Double</td><td>-3.625</td><td>-11.101</td><td>-1.1101 * 2^1</td><td>1 + 01111111111</td><td>1101</td><td>1100000000001101</td></tr>
</tbody></table>
<pre><code class="language-swift">withUnsafeBytes(of: Float(3.625)) { p in
    print(String(UInt16(p[3]) &lt;&lt; 8 + UInt16(p[2]), radix: 2)) // 0100000001101000
}
withUnsafeBytes(of: Float(-3.625)) { p in
    print(String(UInt16(p[3]) &lt;&lt; 8 + UInt16(p[2]), radix: 2)) // 1100000001101000
}

withUnsafeBytes(of: 3.625) { p in
    print(String(UInt16(p[7]) &lt;&lt; 8 + UInt16(p[6]), radix: 2)) // 0100000000001101
}
withUnsafeBytes(of: -3.625) { p in
    print(String(UInt16(p[7]) &lt;&lt; 8 + UInt16(p[6]), radix: 2)) // 1100000000001101
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="程序的机器级表示"><a class="header" href="#程序的机器级表示">程序的机器级表示</a></h1>
<h2 id="条件分支"><a class="header" href="#条件分支">条件分支</a></h2>
<pre><code class="language-c">int abs(int a, int b) {
    if (a &gt; b) {
        return a - b;
    } else {
        return b - a;
    }
}
</code></pre>
<h3 id="条件控制"><a class="header" href="#条件控制">条件控制</a></h3>
<pre><code class="language-asm">_abs:
    cmpl    %esi, %edi
    jle     L2
    movl    %edi, %eax
    subl    %esi, %eax
    ret
L2:
    movl    %esi, %eax
    subl    %edi, %eax
    ret
</code></pre>
<h3 id="条件传送"><a class="header" href="#条件传送">条件传送</a></h3>
<pre><code class="language-asm">_abs:
    movl    %edi, %eax
    subl    %esi, %eax
    movl    %esi, %edx
    subl    %edi, %edx
    cmpl    %esi, %edi
    cmovle  %edx, %eax
    ret
</code></pre>
<h2 id="循环"><a class="header" href="#循环">循环</a></h2>
<h3 id="do-while"><a class="header" href="#do-while">do-while</a></h3>
<pre><code class="language-c">int sum(int n) {
    int res = 0;
    do {
        res += n;
        n -= 1;
    } while (n &gt; 0);
    return res;
}
</code></pre>
<pre><code class="language-asm">_sum:
    movl    $0, %eax
LOOP:
    addl    %edi, %eax
    subl    $1, %edi
    cmpl    $0, %edi
    jg      LOOP
    ret
</code></pre>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<pre><code class="language-c">int sum(int n) {
    int res = 0;
    while (n &gt; 0) {
        res += n;
        n -= 1;
    }
    return res;
}
</code></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<pre><code class="language-c">int sum(int n) {
    int res = 0;
    for (; n &gt; 0; n--) {
        res += n;
    }
    return res;
}
</code></pre>
<h3 id="while-和-for循环jump-to-middle汇编实现"><a class="header" href="#while-和-for循环jump-to-middle汇编实现">while 和 for循环jump to middle汇编实现</a></h3>
<pre><code class="language-asm">_sum:
    movl    $0, %eax
    jmp     TEST
LOOP:
    addl    %edi, %eax
    subl    $1, %edi
TEST:
    cmpl    $0, %edi
    jg      LOOP
    ret
</code></pre>
<h3 id="while-和-for循环guarded-do汇编实现"><a class="header" href="#while-和-for循环guarded-do汇编实现">while 和 for循环guarded-do汇编实现</a></h3>
<pre><code class="language-asm">_sum:
    movl    $0, %eax
    cmpl    $0, %edi
    jle     DONE
LOOP:
    addl    %edi, %eax
    subl    $1, %edi
    cmpl    $0, %edi
    jne     LOOP
    ret
DONE:
    ret
</code></pre>
<h2 id="值传递"><a class="header" href="#值传递">值传递</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int increased(int x) {
    x += 1;
    return x;
}

int main() {
    printf(&quot;%d\n&quot;, increased(0));
    return 0;
}
</code></pre>
<pre><code class="language-asm">_increased:
    movl    %edi, %eax
    addl    $1, %eax
    retq

   .globl  _main
_main:
    pushq   %rbp
    
    movl    $0, %edi
    callq   _increased
    leaq    L_.str(%rip), %rdi
    movl    %eax, %esi
    callq    _printf
    
    movb    $0, %al
    
    popq    %rbp
    retq

L_.str:
    .asciz    &quot;%d\n&quot;
</code></pre>
<h2 id="指针传递"><a class="header" href="#指针传递">指针传递</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void increase(int *x) {
    *x += 1;
}

int main() {
    int x = 0;
    increase(&amp;x);
    printf(&quot;%d\n&quot;, x);
    return 0;
}
</code></pre>
<pre><code class="language-asm">_increase:
    addl    $1, (%rdi)
    retq

   .globl  _main
_main:
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $16, %rsp
    
    movl    $0, -8(%rbp)
    leaq    -8(%rbp), %rdi
    callq   _increase
    leaq    L_.str(%rip), %rdi
    movl    -8(%rbp), %esi
    callq   _printf
    
    movb    $0, %al
    
    addq    $16, %rsp
    popq    %rbp
    retq

L_.str:
    .asciz    &quot;%d\n&quot;
</code></pre>
<h2 id="局部变量"><a class="header" href="#局部变量">局部变量</a></h2>
<pre><code class="language-c">int function() {
    int a = 1;
    int b = 2;
    int c = 3;
    return a + b + c;
}
</code></pre>
<pre><code class="language-asm">_function:
    pushq   %rbp
    pushq   %rbx
    
    movl    $1, %ebp
    movl    $2, %ebx
    movl    $3, %eax
    addl    %ebp, %eax
    addl    %ebx, %eax

    popq    %rbx
    popq    %rbp
    
    retq
</code></pre>
<h2 id="递归"><a class="header" href="#递归">递归</a></h2>
<pre><code class="language-c">int fibonacci(int n) {
    if (n == 0) {
        return 1;
    }
    if (n == 1) {
        return 1;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}
</code></pre>
<pre><code class="language-asm">_fibonacci:
    pushq   %rbp
    pushq   %rbx
    
    cmpl    $0, %edi
    jne      L2
    movl    $1, %eax
    
    popq    %rbx
    popq    %rbp
    ret
L2:
    cmpl    $1, %edi
    jne     L3
    movl    $1, %eax
    
    popq    %rbx
    popq    %rbp
    ret
L3:
    movl    %edi, %ebp
    subl    $1, %edi
    callq   _fibonacci
    movl    %eax, %ebx
    movl    %ebp, %edi
    subl    $2, %edi
    callq   _fibonacci
    addl    %ebx, %eax
    
    popq    %rbx
    popq    %rbp
    ret
</code></pre>
<h2 id="数组"><a class="header" href="#数组">数组</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int subscript_get(int *a, int i) {
    return a[i];
}

void subscript_set(int *a, int i, int x) {
    a[i] = x;
}

int main() {
    int a[5];
    subscript_set(a, 3, 3);
    printf(&quot;%d\n&quot;, subscript_get(a, 3));
    return 0;
}
</code></pre>
<pre><code class="language-asm">_subscript_get:
	movl	(%rdi,%rsi,4), %eax
	retq

_subscript_set:
	movl	%edx, (%rdi,%rsi,4)
	retq

    .globl  _main
_main:
    pushq   %rbp
    movq    %rsp, %rbp
    pushq   %rbx
    subq    $40, %rsp
    
    leaq    -48(%rbp), %rdi
    movl    $3, %esi
    movl    $3, %edx
    callq   _subscript_set
    movl    $3, %esi
    callq   _subscript_get
    leaq    L_.str(%rip), %rdi
    movl    %eax, %esi
    callq   _printf
    
    movb    $0, %al

    addq    $40, %rsp
    popq    %rbx
    popq    %rbp
    retq

L_.str:
    .asciz    &quot;%d\n&quot;
</code></pre>
<h2 id="结构体"><a class="header" href="#结构体">结构体</a></h2>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct T {
    int i;
    char c;
    int a[3];
    char *s;
};


int main() {
    struct T t = {1, 'c', {0, 1, 2}, &quot;hello&quot;};
    printf(&quot;%d, %c, %d, %s\n&quot;, t.i, t.c, t.a[0], t.s);
    return 0;
}
</code></pre>
<pre><code class="language-asm">    .globl    _main
_main:
    pushq   %rbp
    movq    %rsp, %rbp
    subq    $48, %rsp
    
    movq    l___const.main.t(%rip), %rax
    movq    %rax, -40(%rbp)
    movq    l___const.main.t+8(%rip), %rax
    movq    %rax, -32(%rbp)
    movq    l___const.main.t+16(%rip), %rax
    movq    %rax, -24(%rbp)
    movq    l___const.main.t+24(%rip), %rax
    movq    %rax, -16(%rbp)
    movl    -40(%rbp), %esi
    movsbl  -36(%rbp), %edx
    movl    -32(%rbp), %ecx
    movq    -16(%rbp), %r8
    leaq    L_.str.1(%rip), %rdi
    callq   _printf
    
    movb    $0, %al
    
    addq    $48, %rsp
    popq    %rbp
    retq

L_.str:
    .asciz    &quot;hello&quot;

    .section    __DATA,__const
l___const.main.t:
    .long   1
    .byte   99
    .space  3
    .long   0
    .long   1
    .long   2
    .space  4
    .quad   L_.str

L_.str.1:
    .asciz    &quot;%d, %c, %d, %s\n&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="优化程序性能"><a class="header" href="#优化程序性能">优化程序性能</a></h1>
<h2 id="将无需重复执行的代码移出循环"><a class="header" href="#将无需重复执行的代码移出循环">将无需重复执行的代码移出循环</a></h2>
<h3 id="优化前"><a class="header" href="#优化前">优化前</a></h3>
<pre><code class="language-swift">let str = String(repeating: &quot;a&quot;, count: 10_0000)

var i = 0
while i &lt; strlen(str) {
    i += 1
}
</code></pre>
<h3 id="优化后"><a class="header" href="#优化后">优化后</a></h3>
<p>优化前每次循环都会执行一次strlen()，优化后将只需执行一次的strlen()移出循环；
而for-in与while不同，strlen()执行一次生成迭代器之后就不再执行strlen()</p>
<pre><code class="language-swift">let len = strlen(str)

var i = 0
while i &lt; len {
    i += 1
}
</code></pre>
<pre><code class="language-swift">for i in 0..&lt;strlen(str) {
    
}
</code></pre>
<h2 id="将频繁的内存引用合并为一次内存引用"><a class="header" href="#将频繁的内存引用合并为一次内存引用">将频繁的内存引用合并为一次内存引用</a></h2>
<h3 id="优化前-1"><a class="header" href="#优化前-1">优化前</a></h3>
<pre><code class="language-c">long *d = malloc(sizeof(long));
int *a = malloc(sizeof(int) * 100000);
for (int i = 0; i &lt; 100000; i++) {
    a[i] = i;
}

for (int i = 0; i &lt; 100000; i++) {
    *d += a[i];
}
</code></pre>
<h3 id="优化后-1"><a class="header" href="#优化后-1">优化后</a></h3>
<pre><code class="language-c">long t = 0;

for (int i = 0; i &lt; 100000; i++) {
    t += a[i];
}

*d = t;
</code></pre>
<h2 id="循环展开"><a class="header" href="#循环展开">循环展开</a></h2>
<h3 id="优化前-2"><a class="header" href="#优化前-2"><a href="%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD.html#%E4%BC%98%E5%8C%96%E5%89%8D-1">优化前</a></a></h3>
<h3 id="优化后-2"><a class="header" href="#优化后-2">优化后</a></h3>
<pre><code class="language-c">int i;

for (i = 0; i &lt; 100000 - 1; i+=2) {
    *d += (a[i] + a[i+1]);
}

for (; i &lt; 100000; i++) {
    *d += a[i];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="存储器层次结构"><a class="header" href="#存储器层次结构">存储器层次结构</a></h1>
<h2 id="局部性"><a class="header" href="#局部性">局部性</a></h2>
<h3 id="局部性良好高速缓存友好"><a class="header" href="#局部性良好高速缓存友好">局部性良好高速缓存友好</a></h3>
<pre><code class="language-swift">let a = [[Int]](repeating: [Int](0..&lt;10_0000), count: 10_0000)

var sum = 0
for i in 0..&lt;10_0000 {
    for j in 0..&lt;10_0000 {
        sum += a[i][j]
    }
}
</code></pre>
<h3 id="局部性差高速缓存不友好"><a class="header" href="#局部性差高速缓存不友好">局部性差高速缓存不友好</a></h3>
<p>访问完一个子数组之后再访问下一个子数组称为行优先；访问完所有子数组的第一个元素后再访问第二个元素称为列优先。行优先局部性好，在访问子数组的某个元素后，邻近的元素会被从内存加载到高速缓存中，接下来几次内存引用都会缓存命中；列优先局部性差，在访问子数组的某个元素后，跳到下一个子数组访问某个元素，缓存不命中需要直接访问内存</p>
<pre><code class="language-swift">var sum = 0
for j in 0..&lt;10_0000 {
    for i in 0..&lt;10_0000 {
        sum += a[i][j]
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="链接"><a class="header" href="#链接">链接</a></h1>
<h2 id="链接可重定位目标文件"><a class="header" href="#链接可重定位目标文件">链接可重定位目标文件</a></h2>
<h3 id="helloc"><a class="header" href="#helloc">hello.c</a></h3>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void hello(void) {
    printf(&quot;hello\n&quot;);
}
</code></pre>
<h3 id="mainc"><a class="header" href="#mainc">main.c</a></h3>
<pre><code class="language-c">void hello(void);

int main() {
    hello();
    return 0;
}
</code></pre>
<ol>
<li>生成可重定位目标文件 <code>clang -c main.c hello.c</code></li>
<li>链接
<pre><code class="language-shell">SDK=`xcrun --show-sdk-path -sdk macosx`
ld main.o hello.o -lSystem -L $SDK/usr/lib
</code></pre>
</li>
</ol>
<h2 id="链接静态库"><a class="header" href="#链接静态库">链接静态库</a></h2>
<ol>
<li>生成可重定位目标文件 <code>clang -c main.c hello.c</code></li>
<li>生成静态库 <code>ar rcs libhello.a hello.o</code></li>
<li>链接
<pre><code class="language-shell">SDK=`xcrun --show-sdk-path -sdk macosx`
ld main.o -lhello -L. -lSystem -L $SDK/usr/lib
</code></pre>
</li>
</ol>
<h2 id="链接动态库"><a class="header" href="#链接动态库">链接动态库</a></h2>
<ol>
<li>生成动态库（共享目标文件）<code>clang -shared -fpic -o libhello.so hello.c</code></li>
<li>链接
<pre><code class="language-shell">SDK=`xcrun --show-sdk-path -sdk macosx`
ld main.o -lhello -L. -lSystem -L $SDK/usr/lib
</code></pre>
</li>
</ol>
<h2 id="运行时加载动态库"><a class="header" href="#运行时加载动态库">运行时加载动态库</a></h2>
<pre><code class="language-swift">import Foundation

let handle = dlopen(&quot;./libhello.so&quot;, RTLD_LAZY)
if let hello = dlsym(handle, &quot;hello&quot;) {
    let hello = unsafeBitCast(hello, to: (@convention(c) () -&gt; Void).self)
    hello()
    dlclose(handle)
}
</code></pre>
<h2 id="打桩"><a class="header" href="#打桩">打桩</a></h2>
<h3 id="编译时打桩"><a class="header" href="#编译时打桩">编译时打桩</a></h3>
<pre><code class="language-c">// myabs.c
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int myabs(int x) {
    printf(&quot;called abs\n&quot;);
    return abs(x);
}
</code></pre>
<pre><code class="language-c">// stdlib.h
#define abs(x) myabs(x)

int myabs(int x);
</code></pre>
<pre><code class="language-c">// main.c
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int main() {
    int x = abs(-1);
    printf(&quot;%d\n&quot;, x);
    return 0;
}
</code></pre>
<ol>
<li><code>clang -c myabs.c</code></li>
<li><code>clang -I. main.c myabs.o</code></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="异步编程"><a class="header" href="#异步编程">异步编程</a></h1>
<h2 id="背景概念"><a class="header" href="#背景概念">背景概念</a></h2>
<h3 id="处理器central-processing-unit"><a class="header" href="#处理器central-processing-unit">处理器(Central Processing Unit)</a></h3>
<ul>
<li>
<h4 id="单核处理器single-core-processor"><a class="header" href="#单核处理器single-core-processor">单核处理器(Single-core processor)</a></h4>
</li>
<li>
<h4 id="多核处理器multi-core-processor"><a class="header" href="#多核处理器multi-core-processor">多核处理器(Multi-core processor)</a></h4>
</li>
</ul>
<h3 id="任务调度"><a class="header" href="#任务调度">任务调度</a></h3>
<ul>
<li>
<h4 id="线程thread"><a class="header" href="#线程thread">线程(Thread)</a></h4>
<ol>
<li>线程是进程的一部分</li>
<li>多线程间共享进程资源</li>
</ol>
</li>
<li>
<h4 id="进程process"><a class="header" href="#进程process">进程(Process)</a></h4>
<ol>
<li>进程由多个线程组成</li>
<li>多进程间资源独立</li>
</ol>
</li>
</ul>
<h2 id="并发concurrency"><a class="header" href="#并发concurrency">并发(Concurrency)</a></h2>
<ul>
<li>并发指逻辑结构</li>
<li>多任务中的每一任务无需等待上一个任务完成才能开始</li>
<li>多个任务不一定同时执行</li>
<li>异步编程无需关心程序执行状态是否并行，只需要设计出逻辑结构是并发的程序即可</li>
</ul>
<h2 id="并行parallelism"><a class="header" href="#并行parallelism">并行(Parallelism)</a></h2>
<ul>
<li>并行指执行状态</li>
<li>多个任务同时执行</li>
<li>多核处理器可能并行执行并发程序；单核处理器进行多任务轮转造成并发程序并行执行的假象</li>
</ul>
<h2 id="数据竞争"><a class="header" href="#数据竞争">数据竞争</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式"><a class="header" href="#设计模式">设计模式</a></h1>
<h2 id="1-观察者模式"><a class="header" href="#1-观察者模式">1. 观察者模式</a></h2>
<pre><code class="language-swift">class Subject {
    var state = 0

    var observers = [Observer]()

    func append(observer: Observer) {
        observers.append(observer)
    }

    func remove(observer: Observer) {
        observers.removeAll(where: { $0 === observer })
    }


    func notify() {
        observers.forEach({ $0.update(subject: self)} )
    }
}


protocol Observer: class {
    func update(subject: Subject)
}


class ObserverA: Observer {
    func update(subject: Subject) {
        print(&quot;A&quot;, subject.state)
    }
}

class ObserverB: Observer {
    func update(subject: Subject) {
        print(&quot;B&quot;, subject.state)
    }
}

let subject = Subject()
let observerA = ObserverA()
let observerB = ObserverB()

subject.append(observer: observerA)
subject.append(observer: observerB)

subject.state = 1
subject.notify()
// print: A 1
//        B 1
subject.remove(observer: observerA)
subject.state = 2
subject.notify()
// print: B 2
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="词法结构"><a class="header" href="#词法结构">词法结构</a></h1>
<h2 id="注释"><a class="header" href="#注释">注释</a></h2>
<pre><code class="language-swift">// 注释
/*
多行注释
*/
</code></pre>
<h2 id="标识符"><a class="header" href="#标识符">标识符</a></h2>
<pre><code class="language-swift">let 中文 = &quot;也可用作标识符&quot;
let 😄 = &quot;甚至emoji也可以&quot;
let `class` = &quot;保留关键字做标识符需要加反引号&quot;
</code></pre>
<h2 id="关键字"><a class="header" href="#关键字">关键字</a></h2>
<h3 id="声明关键字"><a class="header" href="#声明关键字">声明关键字</a></h3>
<p><code>associatedtype</code>, <code>class</code>, <code>deinit</code>, <code>enum</code>, <code>extension</code>, <code>fileprivate</code>, <code>fun</code>, <code>import</code>, <code>init</code>, <code>inout</code>, <code>internal</code>, <code>let</code>, <code>open</code>, <code>operator</code>, <code>private</code>, <code>precedencegroup</code>, <code>protocol</code>, <code>public</code>, <code>rethrows</code>, <code>static</code>, <code>struct</code>, <code>subscript</code>, <code>typealias</code>, <code>var</code></p>
<h3 id="语句关键字"><a class="header" href="#语句关键字">语句关键字</a></h3>
<p><code>break</code>, <code>case</code>, <code>catch</code>, <code>continue</code>, <code>default</code>, <code>defer</code>, <code>do</code>, <code>else</code>, <code>fallthrough</code>, <code>for</code>, <code>guard</code>, <code>if</code>, <code>in</code>, <code>repeat</code>, <code>return</code>, <code>throw</code>, <code>switch</code>, <code>where</code>, <code>while</code></p>
<h3 id="表达式和类型关键字"><a class="header" href="#表达式和类型关键字">表达式和类型关键字</a></h3>
<p><code>Any</code>, <code>as</code>, <code>catch</code>, <code>false</code>, <code>is</code>, <code>nil</code>, <code>rethrows</code>, <code>self</code>, <code>Self</code>, <code>super</code>, <code>throw</code>, <code>throws</code>, <code>true</code>, <code>try</code></p>
<h3 id="模式关键字"><a class="header" href="#模式关键字">模式关键字</a></h3>
<p><code>_</code></p>
<h3 id="以开头的关键字"><a class="header" href="#以开头的关键字">以#开头的关键字</a></h3>
<p><code>#available</code>, <code>#colorLiteral</code>, <code>#column</code>, <code>#dsohandle</code>, <code>#elseif</code>, <code>#else</code>, <code>#endif</code>, <code>#error</code>, <code>#fileID</code>, <code>#fileLiteral</code>, <code>#filePath</code>, <code>#file</code>, <code>#function</code>, <code>#if</code>, <code>#imageLiteral</code>, <code>#keyPath</code>, <code>#line</code>, <code>#selector</code>, <code>#sourceLocation</code>, <code>#warning</code></p>
<h3 id="仅特定环境保留关键字在环境外可以用作标识符"><a class="header" href="#仅特定环境保留关键字在环境外可以用作标识符">仅特定环境保留关键字（在环境外可以用作标识符）</a></h3>
<p><code>associativity</code>, <code>convenience</code>, <code>didSet</code>, <code>dynamic</code>, <code>final</code>, <code>get</code>, <code>indirect</code>, <code>infix</code>, <code>lazy</code>, <code>left</code>, <code>mutating</code>, <code>none</code>, <code>nonmutating</code>, <code>optional</code>, <code>override</code>, <code>postfix</code>, <code>precedence</code>, <code>prefix</code>, <code>Protocol</code>, <code>required</code>, <code>right</code>, <code>set</code>, <code>some</code>, <code>Type</code>, <code>unowned</code>, <code>weak</code>, <code>willSet</code></p>
<h2 id="字面量"><a class="header" href="#字面量">字面量</a></h2>
<pre><code class="language-swift">33 // 整数字面量
3.1415926 // 浮点数字面量
&quot;Hello, world!&quot; // 字符串字面量
true // 布尔值字面量
nil // 空字面量
</code></pre>
<h3 id="整数字面量"><a class="header" href="#整数字面量">整数字面量</a></h3>
<pre><code class="language-swift">0b11111111 // 二进制整数字面量
0o377 // 八进制整数字面量
0xFF // 十六进制整数字面量
-42 // 负整数字面量
1_000_000 // 以下划线隔开更易读的整数字面量
</code></pre>
<h3 id="浮点数字面量"><a class="header" href="#浮点数字面量">浮点数字面量</a></h3>
<pre><code class="language-swift">1.25e2 // 科学计数法浮点数字面量
1.25e-2
0x1p2 // 十六进制科学计数法浮点数字面量
-42.5 // 负浮点数字面量
-1.000_1 // 以下划线隔开更易读的浮点数字面量
</code></pre>
<h3 id="字符串字面量"><a class="header" href="#字符串字面量">字符串字面量</a></h3>
<pre><code class="language-swift">&quot;字符串&quot;
&quot;&quot;&quot;
多行字符串
&quot;&quot;&quot;

let x = &quot;world&quot;
&quot;Hello, \(x)!&quot;  // 字符串插值

#&quot;\&quot;# // 真实值字符串字面量，显示真实字符而非转义后的字符

&quot;Hello, &quot; + &quot;world!&quot; // 字符串连接（在编译时进行连接）
</code></pre>
<h2 id="运算符"><a class="header" href="#运算符">运算符</a></h2>
<div style="break-before: page; page-break-before: always;"></div><h1 id="类型"><a class="header" href="#类型">类型</a></h1>
<p>命名类型和复合类型</p>
<p>命名类型包含内置类型和自定义类型</p>
<p>复合类型包含函数类型和元组类型</p>
<h2 id="类型标注"><a class="header" href="#类型标注">类型标注</a></h2>
<pre><code class="language-swift">let x: Int = 1 // 显式指定变量类型
</code></pre>
<h2 id="类型标识符"><a class="header" href="#类型标识符">类型标识符</a></h2>
<p>类型标识符指代命名类型或命名类型和复合类型的别名</p>
<pre><code class="language-swift">Int // Int指代Int类型
typealias Point = (Int, Int) // Point指代(Int, Int)类型的别名
</code></pre>
<h2 id="元组类型"><a class="header" href="#元组类型">元组类型</a></h2>
<pre><code class="language-swift">let point: (Int, Int) = (3, 3)
point.0
point.1

let point: (x: Int, y: Int) = (3, 3)
point.x // 命名元组中的元素，用名称来指代元素
point.y

func getPosition() -&gt; (Int, Int) {
    (3, 3) // 函数多返回值
}
let pos = getPosition()
let (x, y) = getPosition()

Void // 空元组 typealias Void = ()
</code></pre>
<h2 id="函数类型"><a class="header" href="#函数类型">函数类型</a></h2>
<p>函数类型表示函数、方法或闭包的类型</p>
<pre><code class="language-swift">let closure: (Int) -&gt; Void
let closure: (_ x: Int) -&gt; Void
</code></pre>
<pre><code class="language-swift">func sum(_ number: Int...) -&gt; Int { // 可变参数
    return number.reduce(0, +)
}

print(sum(0, 1, 2, 3)) // 6
</code></pre>
<pre><code class="language-swift">func increase(_ variable: inout Int) { // 输入输出参数
    variable += 1
}

var variable = 0

increase(&amp;variable)

print(variable) // 1
</code></pre>
<pre><code class="language-swift">func addTo(_ adder: Int) -&gt; (Int) -&gt; Int { // 返回值为函数类型
    return { num in
        adder + num
    }
}

let addToOne = addTo(1)
let addToTwo = addTo(2)

print(addToOne(10)) // 11
print(addToTwo(10)) // 12
</code></pre>
<pre><code class="language-swift">func makeError() throws -&gt; Int { // 抛出异常
    0
}

try makeError()
</code></pre>
<h2 id="数组类型"><a class="header" href="#数组类型">数组类型</a></h2>
<pre><code class="language-swift">let array: [Int] = []

let array: Array&lt;Int&gt; = []

let array = [Int]()
</code></pre>
<h2 id="字典类型"><a class="header" href="#字典类型">字典类型</a></h2>
<pre><code class="language-swift">let dictionary: [String: String] = [:]

let dictionary: Dictionary&lt;String, String&gt; = [:]

let dictionary = [String: String]()
</code></pre>
<h2 id="可选类型"><a class="header" href="#可选类型">可选类型</a></h2>
<pre><code class="language-swift">let option: Int? = nil

let option: Optional&lt;Int&gt; = nil

let option = Int?(nil)
</code></pre>
<h2 id="隐式展开可选类型"><a class="header" href="#隐式展开可选类型">隐式展开可选类型</a></h2>
<pre><code class="language-swift">let option: Int! = nil
let unwrapped: Int = option // Fatal error: Unexpectedly found nil while implicitly unwrapping an Optional value
</code></pre>
<h2 id="协议组合类型"><a class="header" href="#协议组合类型">协议组合类型</a></h2>
<pre><code class="language-swift">typealias Codable = Decodable &amp; Encodable
</code></pre>
<h2 id="不透明类型"><a class="header" href="#不透明类型">不透明类型</a></h2>
<p>不透明类型可以理解为反向范型，范型是由调用者来决定具体类型，不透明类型是由实现来决定具体类型</p>
<p>不透明类型抛弃了协议的动态性，编译时就确定其具体类型</p>
<pre><code class="language-swift">protocol View {
    associatedtype Body
    var body: Body { get }
}

struct AnyView&lt;V&gt;: View {
    typealias Body = V
    
    let view: V
    
    var body: Body {
        view
    }
}

func draw() -&gt; some View {
    AnyView(view: &quot;Hello, world!&quot;)
}
</code></pre>
<h2 id="元类型"><a class="header" href="#元类型">元类型</a></h2>
<pre><code class="language-swift">let x: Int = 1

let type: Int.Type = Int.self
</code></pre>
<h2 id="任意类型"><a class="header" href="#任意类型">任意类型</a></h2>
<pre><code class="language-swift">let x: Any = 1

if let x = x as? Int {
    
}
</code></pre>
<h2 id="自身类型"><a class="header" href="#自身类型">自身类型</a></h2>
<pre><code class="language-swift">struct Car {
    static func create() -&gt; Self {
        return Car()
    }
    
    func start() {
        Self.create()
    }
    
    func run() {
        self.start()
        
        let car: Self = self
        let type: Self.Type = Self.self
    }
}
</code></pre>
<h2 id="类型继承子句"><a class="header" href="#类型继承子句">类型继承子句</a></h2>
<pre><code class="language-swift">class View: UIView, UICollectionViewDelegate, UITableViewDelegate, UITextViewDelegate {

}

enum Network: String {
    case wifi = &quot;en0&quot;
    case cellular = &quot;pdp_ip0&quot;
}
</code></pre>
<h2 id="类型推断"><a class="header" href="#类型推断">类型推断</a></h2>
<pre><code class="language-swift">let x = 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="表达式"><a class="header" href="#表达式">表达式</a></h1>
<h2 id="前缀表达式"><a class="header" href="#前缀表达式">前缀表达式</a></h2>
<h3 id="输入输出表达式"><a class="header" href="#输入输出表达式">输入输出表达式</a></h3>
<pre><code class="language-swift">func increase(_ variable: inout Int) {
    variable += 1
}

var variable = 0

increase(&amp;variable) // 输入输出表达式

print(variable) // 1
</code></pre>
<h3 id="try-运算符"><a class="header" href="#try-运算符">try 运算符</a></h3>
<pre><code class="language-swift">func makeError() throws -&gt; Int {
    throw NSError()
}

func getResult() throws -&gt; Int {
    try makeError()
}

let result: Int? = try? makeError() // nil

let result: Int = try! makeError() // EXC_BAD_INSTRUCTION
</code></pre>
<h3 id="await-运算符"><a class="header" href="#await-运算符">await 运算符</a></h3>
<pre><code class="language-swift">func hello() async -&gt; Int {
    await Task.sleep(1_000_000_000)
    return 1
}

Task {
    let n = await hello()
}
</code></pre>
<h2 id="二元表达式"><a class="header" href="#二元表达式">二元表达式</a></h2>
<h3 id="赋值表达式"><a class="header" href="#赋值表达式">赋值表达式</a></h3>
<pre><code class="language-swift">let x = 1

let (a, b) = (3, 3)
</code></pre>
<h3 id="条件运算符"><a class="header" href="#条件运算符">条件运算符</a></h3>
<pre><code class="language-swift">let bool = [0, 1].randomElement()! == 1 ? true : false
</code></pre>
<h3 id="类型转换运算符"><a class="header" href="#类型转换运算符">类型转换运算符</a></h3>
<pre><code class="language-swift">let string = NSString(string: &quot;abc&quot;)

let object = string as NSObject // 向上转换
let str = object as? NSString // 向下转换

let num = object as? NSNumber // nil
let num = object as! NSNumber // signal SIGABRT
</code></pre>
<pre><code class="language-swift">let string = &quot;String&quot;
let nsString = NSString(string: &quot;NSString&quot;)

let nsStr: NSString = string as NSString // Swift标准库类型与Foundation基础库类型的桥接
let str: String = nsString as String

let nsStr: NSString = NSString(string: string)
let str: String = String(nsString)
</code></pre>
<h2 id="基本表达式"><a class="header" href="#基本表达式">基本表达式</a></h2>
<h3 id="字面量表达式"><a class="header" href="#字面量表达式">字面量表达式</a></h3>
<pre><code class="language-swift">#file
#filePath
#fileID
#line
#column
#function
#dsohandle
</code></pre>
<pre><code class="language-swift">[0, 1, 2, 3]

[&quot;a&quot;: 1, &quot;b&quot;: 2]
</code></pre>
<h3 id="self表达式"><a class="header" href="#self表达式">self表达式</a></h3>
<pre><code class="language-swift">struct SomeStruct {
    func instanceMethod() {
        // 在实例方法中self指代当前实例
        self.instanceMethod()
    }
    
    static func staticMethod() {
        // 在静态方法中self指代当前类型，与Self相同
        self.staticMethod()
        Self.staticMethod()
    }
}
</code></pre>
<pre><code class="language-swift">struct SomeStruct {
    var property: Int
    
    init(property: Int) {
        self.property = property
    }

    init() {
        self.init(property: 1)
    }
}
</code></pre>
<h3 id="super表达式"><a class="header" href="#super表达式">super表达式</a></h3>
<pre><code class="language-swift">class Super {
    init() {
        
    }
}

class Child: Super {
    override init() {
        super.init()
    }
}
</code></pre>
<h3 id="闭包表达式"><a class="header" href="#闭包表达式">闭包表达式</a></h3>
<pre><code class="language-swift">func closure(block: (Int, Int) -&gt; Int) {
    block(1, 2)
}

closure { (x, y) -&gt; Int in
    return x + y
}

closure { x, y in
    x + y
}

closure {
    $0 + $1
}
</code></pre>
<h4 id="捕获列表"><a class="header" href="#捕获列表">捕获列表</a></h4>
<pre><code class="language-swift">var a = 0
var b = 0

let closure = { [a] in
    print(a, b)
}

a = 1
b = 1

closure() // 0 1
</code></pre>
<pre><code class="language-swift">class ReferenceInt {
    var value = 0
}

let a = ReferenceInt()
let b = ReferenceInt()

let closure = { [a] in
    print(a.value, b.value)
}

a.value = 1
b.value = 1

closure() // 1 1
</code></pre>
<pre><code class="language-swift">class Strong {
    var closure: () -&gt; Void = {}
    
    init() {
        closure = { // [self] in
            print(self.closure)
        }
    }
    
    deinit {
        print(self)
    }
}

class Weak {
    var closure: () -&gt; Void = {}
    
    init() {
        closure = { [weak self] in
            print(self?.closure)
        }
    }
    
    deinit {
        print(self)
    }
}

var a: Strong? = Strong()
var b: Weak? = Weak()

a = nil
b = nil // 只有Weak被释放了
</code></pre>
<h3 id="隐式成员表达式"><a class="header" href="#隐式成员表达式">隐式成员表达式</a></h3>
<pre><code class="language-swift">let zero = Int.zero

let zero: Int = .zero
</code></pre>
<h3 id="括号表达式"><a class="header" href="#括号表达式">括号表达式</a></h3>
<pre><code class="language-swift">extension String {
    var firstLetterUppercased: String {
        // 使用括号更改默认优先级的符号运算顺序
        (first?.uppercased() ?? &quot;&quot;) + dropFirst()
    }
}
</code></pre>
<h3 id="元组表达式"><a class="header" href="#元组表达式">元组表达式</a></h3>
<pre><code class="language-swift">(3, 3)

(x: 3, y: 3)
</code></pre>
<h3 id="通配符表达式"><a class="header" href="#通配符表达式">通配符表达式</a></h3>
<pre><code class="language-swift">let (x, _) = (3, 3)


func closure(block: (Int, Int) -&gt; Void) -&gt; Int {
    1
}

_ = closure { x, _ in
    
}
</code></pre>
<h3 id="key-path表达式"><a class="header" href="#key-path表达式">Key-Path表达式</a></h3>
<pre><code class="language-swift">&quot;Hello, world!&quot;[keyPath: \String.count]
</code></pre>
<pre><code class="language-swift">var index = 0
let path = \[Int].[index]

print([0, 1, 2][keyPath: path]) // 0
index += 1
print([0, 1, 2][keyPath: path]) // 0
</code></pre>
<pre><code class="language-swift">struct Task {
    var done: Bool
}

let todoList = [
    Task(done: true),
    Task(done: false)
]

let doneTasks = todoList.filter(\.done)
</code></pre>
<h3 id="selector表达式"><a class="header" href="#selector表达式">Selector表达式</a></h3>
<pre><code class="language-swift">class SomeClass {
    @objc let property = 0
    
    @objc func method() {
        
    }
}

let selectorForProperty = #selector(getter: SomeClass.property)
let selectorForMethod = #selector(SomeClass.method)
</code></pre>
<h3 id="key-path字符串表达式"><a class="header" href="#key-path字符串表达式">Key-Path字符串表达式</a></h3>
<pre><code class="language-swift">class SomeClass: NSObject {
    @objc let property = 0
}

let keyPathString = #keyPath(SomeClass.property) // &quot;property&quot;
let value = SomeClass().value(forKey: keyPathString)
</code></pre>
<h2 id="后缀表达式"><a class="header" href="#后缀表达式">后缀表达式</a></h2>
<h3 id="函数调用表达式"><a class="header" href="#函数调用表达式">函数调用表达式</a></h3>
<pre><code class="language-swift">func someFunction(_ x: Int) {

}

func someFunction(x: Int) {

}

someFunction(0)
someFunction(x: 1)
</code></pre>
<pre><code class="language-swift">func someFunction(completion: () -&gt; Void) {

}

someFunction(completion: {

})

someFunction() {

}

someFunction {

}
</code></pre>
<pre><code class="language-swift">func someFunction(x: Int, success: () -&gt; Void, failure: () -&gt; Void) {

}

someFunction(x: 1, success: {

}, failure: {

})

someFunction(x: 1) {

} failure: {

}
</code></pre>
<h4 id="隐式转换为指针类型"><a class="header" href="#隐式转换为指针类型">隐式转换为指针类型</a></h4>
<pre><code class="language-swift">var a = 0

func implicit(pointer: UnsafePointer&lt;Int&gt;) {
    
}

withUnsafePointer(to: &amp;a) { pointer in
    
}

implicit(pointer: &amp;a) // inout输入输出参数隐式转换为UnsafePointer或UnsafeMutablePointer指针类型
</code></pre>
<h3 id="初始化器表达式"><a class="header" href="#初始化器表达式">初始化器表达式</a></h3>
<pre><code class="language-swift">let zero = Int()
let zero = Int.init()

let metaType = Int.self
let zero = metaType.init()
</code></pre>
<pre><code class="language-swift">let stringArray = [0, 1, 2].map(String.init)
let stringArray = [0, 1, 2].map { String($0) }
</code></pre>
<h3 id="显示成员表达式"><a class="header" href="#显示成员表达式">显示成员表达式</a></h3>
<pre><code class="language-swift">struct SomeStructure {
    func someMethod(x: Int) {}
    func someMethod(y: Int) {}
    func overloadedMethod(x: Int) {}
    func overloadedMethod(x: Bool) {}
}

let instance = SomeStructure()

let method = instance.someMethod(x:)
let overloadedMethod: (Int) -&gt; Void = instance.overloadedMethod(x:)
</code></pre>
<h3 id="后缀self表达式"><a class="header" href="#后缀self表达式">后缀self表达式</a></h3>
<pre><code class="language-swift">let number: Int = 1.self
let metaType: Int.Type = Int.self
</code></pre>
<h3 id="下标表达式"><a class="header" href="#下标表达式">下标表达式</a></h3>
<pre><code class="language-swift">var array = [0, 1, 2]
array[0] = array[1]
</code></pre>
<h3 id="强制取值表达式"><a class="header" href="#强制取值表达式">强制取值表达式</a></h3>
<pre><code class="language-swift">var x: Int? = 0

x! += 1

let unwrapped = x!
</code></pre>
<h3 id="可选链表达式"><a class="header" href="#可选链表达式">可选链表达式</a></h3>
<pre><code class="language-swift">let string: String? = &quot;Hello, world!&quot;

print(string?.first?.lowercased()) // Optional(&quot;h&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语句"><a class="header" href="#语句">语句</a></h1>
<h2 id="循环语句"><a class="header" href="#循环语句">循环语句</a></h2>
<h3 id="for-in-循环"><a class="header" href="#for-in-循环">For-In 循环</a></h3>
<pre><code class="language-swift">for i in 0..&lt;3 {
    print(i)
}
</code></pre>
<h4 id="步长不为一或倒序"><a class="header" href="#步长不为一或倒序">步长不为一或倒序</a></h4>
<pre><code class="language-swift">for i in stride(from: 0, to: 10, by: 2) {
    print(i) // 0 2 4 6 8
}
</code></pre>
<h3 id="while-循环"><a class="header" href="#while-循环">While 循环</a></h3>
<pre><code class="language-swift">var i = 0
while i &lt; 3 {
    print(i)
    
    i += 1
}
</code></pre>
<h3 id="repeat-while-循环"><a class="header" href="#repeat-while-循环">Repeat-While 循环</a></h3>
<pre><code class="language-swift">// while第一次判断条件不满足直接不执行
// repeat while即使第一次判断条件不满足也会至少执行一次
var i = 0
repeat {
    print(i)
    
    i += 1
} while i &lt; 3
</code></pre>
<h2 id="分支语句"><a class="header" href="#分支语句">分支语句</a></h2>
<h3 id="if-语句"><a class="header" href="#if-语句">if 语句</a></h3>
<pre><code class="language-swift">func someMethod(x: Int) {
    if x &gt; 1 {
        
    } else if x &gt; 0 {
        
    } else {
        
    }
}
</code></pre>
<pre><code class="language-swift">// 可选绑定
if let zero = Int(&quot;0&quot;) {
    
}
</code></pre>
<pre><code class="language-swift">let result = Result&lt;Int, NSError&gt;.success(1)

// case 模式匹配
if case let .success(x) = result {
    print(x)
}


let dualOption: Int?? = 1

if case let x?? = dualOption {
    print(x)
}
</code></pre>
<h3 id="guard-语句"><a class="header" href="#guard-语句">guard 语句</a></h3>
<pre><code class="language-swift">func someMethod(x: Int) {
    guard x &gt; 0 else { return }
    
}
</code></pre>
<pre><code class="language-swift">func someMethod() {
    guard let zero = Int(&quot;0&quot;) else { return }
}
</code></pre>
<h3 id="switch-语句"><a class="header" href="#switch-语句">switch 语句</a></h3>
<pre><code class="language-swift">switch UIDevice.current.userInterfaceIdiom {
case .mac:
    print(&quot;mac&quot;)
case .phone:
    print(&quot;phone&quot;)
case .pad:
    print(&quot;pad&quot;)
default:
    break
}
</code></pre>
<pre><code class="language-swift">func someMethod(string: String) {
    if string.hasPrefix(&quot;a&quot;) {
        print(&quot;a&quot;)
    } else if string.hasPrefix(&quot;b&quot;) {
        print(&quot;b&quot;)
    } else if string.hasPrefix(&quot;c&quot;) {
        print(&quot;c&quot;)
    } else {
        print(&quot;unknown&quot;)
    }
}

// case let where 模式匹配替换if else
func someMethod(string: String) {
    switch string {
    case let string where string.hasPrefix(&quot;a&quot;):
        print(&quot;a&quot;)
    case let string where string.hasPrefix(&quot;b&quot;):
        print(&quot;b&quot;)
    case let string where string.hasPrefix(&quot;c&quot;):
        print(&quot;c&quot;)
    default:
        print(&quot;unknown&quot;)
    }
}
</code></pre>
<h2 id="带标签的语句"><a class="header" href="#带标签的语句">带标签的语句</a></h2>
<pre><code class="language-swift">label: if true {
    while true {
        if true {
            print(&quot;inside&quot;)
            break label
        }
    }
    // break本应跳出while循环，break label指定了要跳出的标签，最终跳出了if语句
    print(&quot;outside&quot;) // 将不会被执行
}
</code></pre>
<h2 id="控制转移语句"><a class="header" href="#控制转移语句">控制转移语句</a></h2>
<pre><code class="language-swift">while true {
    break
}

for i in 0..&lt;3 {
    if i &lt; 1 {
        continue
    }
    print(i) // 1 2
}

func someMethod() {
    return
}

func makeError() throws {
    throw NSError()
}
</code></pre>
<h2 id="defer-语句"><a class="header" href="#defer-语句">defer 语句</a></h2>
<pre><code class="language-swift">func someMethod() {
    let pointer = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1)
    // defer 推迟到退出当前作用域之前执行
    defer {
        pointer.deallocate()
    }
    
    pointer.initialize(to: 0)
}
</code></pre>
<h2 id="do-语句"><a class="header" href="#do-语句">do 语句</a></h2>
<pre><code class="language-swift">do {
    try String(contentsOfFile: &quot;&quot;)
} catch let error {
    print(error) // Error Domain=NSCocoaErrorDomain Code=258 &quot;The item couldn’t be opened because the file name “” is invalid.&quot; UserInfo={NSFilePath=}
}
</code></pre>
<pre><code class="language-swift">// 引入一个新的作用域，分隔代码块的界限，不会损失性能
do {
    print(&quot;Hello, world!&quot;)
}
</code></pre>
<h2 id="编译器控制语句"><a class="header" href="#编译器控制语句">编译器控制语句</a></h2>
<h3 id="条件编译代码块"><a class="header" href="#条件编译代码块">条件编译代码块</a></h3>
<pre><code class="language-swift">#if os(iOS) || os(tvOS)
import UIKit
#elseif os(macOS)
import AppKit
#elseif os(watchOS)
import WatchKit
#elseif os(Linux) || os(Windows)
#else
#endif

#if arch(i386) || arch(x86_64)
#elseif arch(arm) || arch(arm64)
#endif

#if swift(&gt;=5)
#endif

#if compiler(&gt;=5)
#endif

#if canImport(SwiftUI)
import SwiftUI
#endif

#if targetEnvironment(simulator)
#elseif targetEnvironment(macCatalyst)
#endif
</code></pre>
<h3 id="行控制语句"><a class="header" href="#行控制语句">行控制语句</a></h3>
<pre><code class="language-swift">#sourceLocation(file: &quot;name&quot;, line: 1)

print(#file, #line) // name 2

#sourceLocation()

print(#file, #line) // 文件名和行号被重置
</code></pre>
<h3 id="编译时诊断语句"><a class="header" href="#编译时诊断语句">编译时诊断语句</a></h3>
<pre><code class="language-swift">#error(&quot;错误&quot;)

#warning(&quot;警告&quot;)
</code></pre>
<h2 id="可用性条件"><a class="header" href="#可用性条件">可用性条件</a></h2>
<pre><code class="language-swift">if #available(iOS 13.0, *) {
    
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="声明"><a class="header" href="#声明">声明</a></h1>
<h2 id="顶级代码"><a class="header" href="#顶级代码">顶级代码</a></h2>
<pre><code class="language-swift">print(&quot;Hello, world!&quot;)
</code></pre>
<h2 id="代码块"><a class="header" href="#代码块">代码块</a></h2>
<pre><code class="language-swift">do {
    
}
</code></pre>
<h2 id="导入声明"><a class="header" href="#导入声明">导入声明</a></h2>
<pre><code class="language-swift">import Foundation

import Foundation.NSObject

import struct Foundation.CGFloat

import class Foundation.NSObject
</code></pre>
<h2 id="常量声明"><a class="header" href="#常量声明">常量声明</a></h2>
<pre><code class="language-swift">let zero = 0

let zero: Int = 0
</code></pre>
<h2 id="变量声明"><a class="header" href="#变量声明">变量声明</a></h2>
<h3 id="存储变量和存储属性"><a class="header" href="#存储变量和存储属性">存储变量和存储属性</a></h3>
<pre><code class="language-swift">var x = 1

var x: Int = 1
</code></pre>
<h3 id="计算变量和计算属性"><a class="header" href="#计算变量和计算属性">计算变量和计算属性</a></h3>
<pre><code class="language-swift">var number = 1

var opposite: Int {
    get {
        -number
    }
    
    set {
        number = -newValue
    }
    
//    set(newNumber) {
//        number = -newNumber
//    }
}

print(opposite) // -1
opposite = 3
print(number) // -3
</code></pre>
<pre><code class="language-swift">var bit = 8

var byte: Int {
    bit / 8
    
//    get {
//        bit / 8
//    }
}
</code></pre>
<h3 id="存储变量观察器和存储属性观察器"><a class="header" href="#存储变量观察器和存储属性观察器">存储变量观察器和存储属性观察器</a></h3>
<pre><code class="language-swift">var x = 0 {
    willSet {
        print(&quot;\(x) will set to \(newValue)&quot;)
    }
    
    didSet {
        print(&quot;\(oldValue) did set to \(x)&quot;)
    }
}

x = 1
// 0 will set to 1
// 0 did set to 1
</code></pre>
<h3 id="类型的属性"><a class="header" href="#类型的属性">类型的属性</a></h3>
<pre><code class="language-swift">struct SomeStructure {
    static var x = 0
    
    static var y: Int {
        1
    }
}

class SomeClass {
    static var x = 0
    
    static var y: Int {
        1
    }
}
</code></pre>
<pre><code class="language-swift">class Super {
    class var x: Int {
        0
    }
}

class Child: Super {
    override class var x: Int {
        1
    }
}
</code></pre>
<h2 id="类型别名声明"><a class="header" href="#类型别名声明">类型别名声明</a></h2>
<pre><code class="language-swift">typealias Dict = Dictionary
typealias StringDict&lt;Value&gt; = Dictionary&lt;String, Value&gt;

let dict1: Dict&lt;String, Int&gt; = [:]
let dict2: StringDict&lt;Int&gt; = [:]
</code></pre>
<h2 id="函数声明"><a class="header" href="#函数声明">函数声明</a></h2>
<h3 id="参数名"><a class="header" href="#参数名">参数名</a></h3>
<pre><code class="language-swift">func f(a: Int, b: Int) -&gt; Int {
    a + b
}

f(a: 0, b: 1)

func f(_ a: Int, x b: Int) -&gt; Int {
    a + b
}

f(0, x: 1)
</code></pre>
<h3 id="输入输出参数"><a class="header" href="#输入输出参数">输入输出参数</a></h3>
<p>调用函数时，复制参数；在函数中，副本被修改；函数返回时，副本被赋值给原参数</p>
<pre><code class="language-swift">var _x = 0
var x: Int {
    get {
        print(&quot;copy in&quot;)
        return _x
    }

    set {
        _x = newValue
        print(&quot;copy out&quot;)
    }
}

func f(x: inout Int) {
    x = 1
    print(&quot;copy is modified&quot;)
    return
}

f(x: &amp;x)
// copy in
// copy is modified
// copy out
</code></pre>
<pre><code class="language-swift">var x = 0

// 捕获输入输出参数，不改变它
func f(x: inout Int) {
    DispatchQueue.global().async { [x] in
        print(x + 1)
    }
}

// 捕获输入输出参数，并改变它
func f(x: inout Int) {
    var local = x
    defer {
        x = local
    }

    let queue = DispatchQueue(label: &quot;serial&quot;)
    queue.async {
        local += 1
    }
    queue.sync {}
}
</code></pre>
<h3 id="特殊参数"><a class="header" href="#特殊参数">特殊参数</a></h3>
<pre><code class="language-swift">func sum(_ number: Int...) -&gt; Int { // 可变参数
    return number.reduce(0, +)
}

print(sum(0, 1, 2, 3)) // 6


func printInt(_ value: Int = 0) {
    print(value)
}

printInt() // 0
printInt(1) // 1
</code></pre>
<h3 id="特殊方法"><a class="header" href="#特殊方法">特殊方法</a></h3>
<pre><code class="language-swift">struct SomeStructure {
    var x = 0

    mutating func modify() {
        x += 1
    }
}


class Super {
    func method() {

    }
}

class Child: Super {
    override func method() {

    }
}


class SomeClass {
    // Cannot override static method
    static func typeMethod1() {
        
    }
    
    // Class method overrides a 'final' class method
    final class func typeMethod2() {
        
    }
    
    // 允许子类重写
    class func typeMethod3() {
        
    }
}
</code></pre>
<h3 id="特殊名称方法"><a class="header" href="#特殊名称方法">特殊名称方法</a></h3>
<pre><code class="language-swift">struct AddTo {
    var adder: Int
    
    func callAsFunction(_ num: Int) -&gt; Int {
        adder + num
    }
}


let addToOne = AddTo(adder: 1)
let addToTwo = AddTo(adder: 2)

print(addToOne(10)) // 11
print(addToTwo(10)) // 12
</code></pre>
<h3 id="抛出异常的函数和方法"><a class="header" href="#抛出异常的函数和方法">抛出异常的函数和方法</a></h3>
<pre><code class="language-swift">func makeError() throws -&gt; Int {
    throw NSError()
}
</code></pre>
<h3 id="重抛异常的函数和方法"><a class="header" href="#重抛异常的函数和方法">重抛异常的函数和方法</a></h3>
<pre><code class="language-swift">func rethrowError(block: () throws -&gt; Void) rethrows {
    try block()
}

// 函数将闭包内的异常再次抛出以交由外部处理
try? rethrowError {
    throw NSError()
}
</code></pre>
<h3 id="异步函数和方法"><a class="header" href="#异步函数和方法">异步函数和方法</a></h3>
<pre><code class="language-swift">func hello() async -&gt; Int {
    try! await Task.sleep(nanoseconds: 1000_000_000)
    return 1
}

let n = await hello()
</code></pre>
<h3 id="永不返回的函数"><a class="header" href="#永不返回的函数">永不返回的函数</a></h3>
<pre><code class="language-swift">func crash() -&gt; Never {
    fatalError(&quot;bad apple&quot;)
}
</code></pre>
<h2 id="枚举声明"><a class="header" href="#枚举声明">枚举声明</a></h2>
<pre><code class="language-swift">enum SomeEnumeration: Equatable {
    case aCase
    case withAssociatedValue(Int)
}


// 数值类型枚举默认rawValue值自动递增
enum RawIntEnumeration: Int {
    case aCase = 10
    case bCase // rawValue 11
}

// 字符串类型枚举默认rawValue值与标识符相同
enum RawStringEnumeration: String {
    case aCase // rawValue &quot;aCase&quot;
    case bCase // rawValue &quot;bCase&quot;
}
</code></pre>
<pre><code class="language-swift">indirect enum LinkedNode {
    case empty
    case node(Int, LinkedNode)
}

let linkedList = LinkedNode.node(0, .node(1, .node(2, .empty)))

print(linkedList) // node(0, node(1, .node(2, .empty)))
</code></pre>
<h2 id="结构体声明"><a class="header" href="#结构体声明">结构体声明</a></h2>
<pre><code class="language-swift">struct SomeStructure {
    
}
</code></pre>
<h2 id="类声明"><a class="header" href="#类声明">类声明</a></h2>
<pre><code class="language-swift">class SomeClass {
    
}
</code></pre>
<h2 id="参与者声明"><a class="header" href="#参与者声明">参与者声明</a></h2>
<pre><code class="language-swift">actor SomeActor {
    
}
</code></pre>
<h2 id="协议声明"><a class="header" href="#协议声明">协议声明</a></h2>
<pre><code class="language-swift">protocol SomeProtocol {
    associatedtype SomeType
    
    var x: SomeType { get set}
    
    func method()
    subscript() -&gt; Int { get set }
}
</code></pre>
<pre><code class="language-swift">// 仅类可以实现的协议
protocol ClassOnlyProtocol: AnyObject {
    
}
</code></pre>
<h2 id="初始化器声明"><a class="header" href="#初始化器声明">初始化器声明</a></h2>
<pre><code class="language-swift">class Super {
    var father: Int
    
    // designated initializer
    init(father: Int) {
        self.father = father
    }
}


class Child: Super {
    var child: Int
    
    override init(father: Int) {
        child = 0
        super.init(father: 0)
        self.father = 1
    }
    
    // designated initializer
    init(child: Int) throws {
        self.child = child
        super.init(father: 0)
        father = 1
    }
    
    // convenience initializer
    convenience init() throws {
        try self.init(child: 1)
    }
}
</code></pre>
<pre><code class="language-swift">struct PositiveNumberString {
    var value: String

    // 可失败初始化器
    init?(_ value: Int) {
        guard value &gt; 0 else { return nil }
        self.value = String(value)
    }
}

if let str = PositiveNumberString(-1) {

}
</code></pre>
<h2 id="反初始化器声明"><a class="header" href="#反初始化器声明">反初始化器声明</a></h2>
<pre><code class="language-swift">deinit {
    
}
</code></pre>
<h2 id="扩展声明"><a class="header" href="#扩展声明">扩展声明</a></h2>
<pre><code class="language-swift">protocol SomeProtocol {
    
}

struct SomeStructure {
    
}

extension SomeStructure: SomeProtocol {
    
}
</code></pre>
<pre><code class="language-swift">protocol SomeProtocol {
    func method()
}

extension SomeProtocol {
    func method() {
        
    }
}

struct SomeStructure {
    
}

extension SomeStructure: SomeProtocol {
    
}
</code></pre>
<pre><code class="language-swift">protocol Serializable {
    func serialize()
}

protocol SerializableInArray { }
extension Int: SerializableInArray { }
extension String: SerializableInArray { }

extension Array: Serializable where Element: SerializableInArray {
    func serialize() {
        
    }
}
</code></pre>
<h2 id="下标声明"><a class="header" href="#下标声明">下标声明</a></h2>
<pre><code class="language-swift">struct List {
    var array: [Int]
    
    subscript(index: Int) -&gt; Int {
        get {
            array[index]
        }
        
        set {
            array[index] = newValue
        }
    }
}

print(List(array: [0, 1, 2])[0]) // 0
</code></pre>
<h2 id="运算符声明"><a class="header" href="#运算符声明">运算符声明</a></h2>
<pre><code class="language-swift">postfix operator ++
prefix operator ++
infix operator ++

extension Int {
    static postfix func ++(i: inout Int) {
        i += 1
    }
    
    static prefix func ++(i: inout Int) {
        i += 1
    }
    
    static func ++(left: Int, right: Int) -&gt; Int {
        left + right
    }
}

var i = 0
i++
++i
print(i) // 2
print(1 ++ i) // 3
</code></pre>
<h2 id="优先级组声明"><a class="header" href="#优先级组声明">优先级组声明</a></h2>
<pre><code class="language-swift">precedencegroup 优先级组名称{
    higherThan: 较低优先级组的名称
    lowerThan: 较高优先级组的名称
    associativity: 结合性
    assignment: 赋值性
}
</code></pre>
<h2 id="声明修饰符"><a class="header" href="#声明修饰符">声明修饰符</a></h2>
<p><code>class</code> 修饰符表明是类自身的成员，而不是类实例的成员</p>
<p><code>dynamic</code> 修饰由Objective-C Runtime动态派发的成员</p>
<p><code>final</code> 限制类被继承，限制类成员被重写</p>
<p><code>lazy</code> 修饰的属性第一次被访问时，计算和存储一次</p>
<p><code>optional</code> 修饰@objc协议的可选成员</p>
<p><code>required</code> 修饰的初始化器子类必须实现</p>
<p><code>static</code> 修饰类型成员，而不是类实例成员，且不允许子类重写</p>
<p><code>unowned</code> 无主引用</p>
<p><code>weak</code> 弱引用</p>
<h3 id="访问控制级别"><a class="header" href="#访问控制级别">访问控制级别</a></h3>
<pre><code class="language-swift">private
fileprivate
internal
public
open
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="特性"><a class="header" href="#特性">特性</a></h1>
<h2 id="available"><a class="header" href="#available">available</a></h2>
<pre><code class="language-swift">@available(iOS 13.0, *)
@available(iOSApplicationExtension, unavailable)
@available(swift 5)
@available(iOS, introduced: 13.0) // is only available in iOS 13.0 or newer
@available(iOS, deprecated: 13.0) // is deprecated: deprecated
@available(iOS, obsoleted: 13.0) // is unavailable in iOS
@available(*, deprecated, message: &quot;deprecated&quot;)
@available(*, unavailable, renamed: &quot;newname&quot;) // has been renamed to 'newname'
</code></pre>
<h2 id="discardableresult"><a class="header" href="#discardableresult">discardableResult</a></h2>
<pre><code class="language-swift">@discardableResult
func someFunction() -&gt; Int {
    1
}

someFunction()
</code></pre>
<h2 id="dynamiccallable"><a class="header" href="#dynamiccallable">dynamicCallable</a></h2>
<pre><code class="language-swift">import JavaScriptCore

@dynamicCallable
struct JSFunctionWrapper {
    let value: JSValue

    func dynamicallyCall(withArguments args: [Any]) -&gt; JSValue {
        value.call(withArguments: args)
    }
    
    func dynamicallyCall(withKeywordArguments pairs: [String: Any]) -&gt; JSValue {
        value.call(withArguments: [pairs[&quot;a&quot;]!, pairs[&quot;b&quot;]!])
    }
}

let context: JSContext = JSContext()
context.evaluateScript(
&quot;&quot;&quot;
function sum(a, b) {
    return a + b
}
&quot;&quot;&quot;
)
let sumValue: JSValue = context.evaluateScript(&quot;sum&quot;)

let sum = JSFunctionWrapper(value: sumValue)
print(sum(1, 2)) // 3
print(sum(a: 1, b: 2)) // 3
</code></pre>
<h2 id="dynamicmemberlookup"><a class="header" href="#dynamicmemberlookup">dynamicMemberLookup</a></h2>
<pre><code class="language-swift">@dynamicMemberLookup
struct DynamicDict {
    let dict: [String: Int]
    
    subscript(dynamicMember key: String) -&gt; Int? {
        dict[key]
    }
}

let dict = DynamicDict(dict: [&quot;a&quot;: 1])
print(dict.a) // Optional(1)
print(dict.b) // nil
</code></pre>
<h2 id="frozen"><a class="header" href="#frozen">frozen</a></h2>
<p>冻结对枚举的case和结构体的存储属性进行添加、删除、重新排序的操作，以保证发布二进制库的ABI兼容</p>
<h2 id="main"><a class="header" href="#main">main</a></h2>
<pre><code class="language-swift">@main
struct Main {
    static func main() {
        print(&quot;Hello, world!&quot;)
    }
}
</code></pre>
<h2 id="nonobjc"><a class="header" href="#nonobjc">nonobjc</a></h2>
<pre><code class="language-swift">@objcMembers
public class OCBridge: NSObject {
    @nonobjc public func onlyInSwift() {
        
    }
}
</code></pre>
<h2 id="objc"><a class="header" href="#objc">objc</a></h2>
<pre><code class="language-swift">public class OCBridge: NSObject {
    @objc func compatibleMethod() {
        
    }
    
    @objc(ocMethod)
    func swiftMethod() {
        
    }
}
</code></pre>
<h2 id="objcmembers"><a class="header" href="#objcmembers">objcMembers</a></h2>
<pre><code class="language-swift">@objcMembers
public class OCBridge: NSObject {
    
}
</code></pre>
<h2 id="propertywrapper"><a class="header" href="#propertywrapper">propertyWrapper</a></h2>
<pre><code class="language-swift">@propertyWrapper
struct UserDefault&lt;T&gt; {
    let key: String
    let defaultValue: T
    
    init(wrappedValue defaultValue: T, _ key: String) {
        self.key = key
        self.defaultValue = defaultValue
    }
    
    var wrappedValue: T {
        get {
            UserDefaults.standard.object(forKey: key) as? T ?? defaultValue
        }

        set {
            UserDefaults.standard.set(newValue, forKey: key)
        }
    }
    
    var projectedValue: T? {
        UserDefaults.standard.object(forKey: key) as? T
    }
}

struct AppConfig {
    @UserDefault(&quot;hasAppLaunchedOnce&quot;) static var hasAppLaunchedOnce: Bool = false
}

var isFirstLaunch: Bool {
    if AppConfig.hasAppLaunchedOnce {
        return false
    }

    AppConfig.hasAppLaunchedOnce = true
    return true
}

print(isFirstLaunch) // true false
print(AppConfig.hasAppLaunchedOnce) // false true
print(AppConfig.$hasAppLaunchedOnce) // Optional(false) Optional(true)
</code></pre>
<h2 id="resultbuilder"><a class="header" href="#resultbuilder">resultBuilder</a></h2>
<pre><code class="language-swift">@resultBuilder struct Paragraph {
    static func buildBlock(_ sentences: String...) -&gt; String {
        sentences.joined(separator: &quot;\n&quot;)
    }
}

@Paragraph
func makeParagraph() -&gt; String {
    &quot;resultBuilder&quot;
    &quot;hello&quot;
    &quot;world&quot;
}

print(makeParagraph())
// resultBuilder
// hello
// world
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-56"><a class="header" href="#swift-56">Swift 5.6</a></h1>
<h2 id="不可用条件"><a class="header" href="#不可用条件">不可用条件</a></h2>
<pre><code class="language-swift">if #available(iOS 13, *) {} else {

}

if #unavailable(iOS 13) {

}
</code></pre>
<h2 id="类型占位符"><a class="header" href="#类型占位符">类型占位符</a></h2>
<pre><code class="language-swift">let x: _? = 1

let dict: [String: _] = [&quot;a&quot;: 1]
</code></pre>
<h2 id="临时未初始化的缓冲区"><a class="header" href="#临时未初始化的缓冲区">临时未初始化的缓冲区</a></h2>
<pre><code class="language-swift">// 堆上分配
let pointer = UnsafeMutableBufferPointer&lt;Int&gt;.allocate(capacity: 3)

pointer.deallocate()

// 栈上分配
withUnsafeTemporaryAllocation(of: Int.self, capacity: 3) { pointer in

}
</code></pre>
<h2 id="放宽-c-函数指针参数的诊断"><a class="header" href="#放宽-c-函数指针参数的诊断">放宽 C 函数指针参数的诊断</a></h2>
<p><code>UnsafeMutableRawPointer</code> 可以自动转化为 <code>UnsafeMutabelPointer&lt;UInt8&gt;</code></p>
<h2 id="引入存在any"><a class="header" href="#引入存在any">引入存在any</a></h2>
<pre><code class="language-swift">protocol P {

}

let p: P
let p: any P
</code></pre>
<h2 id="具体实例"><a class="header" href="#具体实例">具体实例</a></h2>
<h3 id="临时未初始化的缓冲区-1"><a class="header" href="#临时未初始化的缓冲区-1">临时未初始化的缓冲区</a></h3>
<pre><code class="language-swift">import CommonCrypto

let data = &quot;Hello, world!&quot;.data(using: .utf8)!

let digest: Data = data.withUnsafeBytes { dataPointer in
    withUnsafeTemporaryAllocation(of: UInt8.self, capacity: Int(CC_MD5_DIGEST_LENGTH)) { digestPointer in
        CC_MD5(dataPointer.baseAddress, CC_LONG(data.count), digestPointer.baseAddress)
        return Data(buffer: digestPointer)
    }
}

print(digest.reduce(&quot;&quot;, { partialResult, code in
    partialResult + String(format: &quot;%02x&quot;, code)
}))
</code></pre>
<h3 id="放宽-c-函数指针参数的诊断-1"><a class="header" href="#放宽-c-函数指针参数的诊断-1">放宽 C 函数指针参数的诊断</a></h3>
<pre><code class="language-swift">import CommonCrypto

let data = &quot;Hello, world!&quot;.data(using: .utf8)!
var digest = [UInt8](repeating: 0, count: Int(CC_MD5_DIGEST_LENGTH))

data.withUnsafeBytes { dataPointer in
    digest.withUnsafeMutableBytes { digestPointer in
//        CC_MD5(dataPointer.baseAddress, CC_LONG(data.count), digestPointer.baseAddress?.assumingMemoryBound(to: UInt8.self))
        CC_MD5(dataPointer.baseAddress, CC_LONG(data.count), digestPointer.baseAddress)
    }
}

print(digest.reduce(&quot;&quot;, { partialResult, code in
    partialResult + String(format: &quot;%02x&quot;, code)
}))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据结构"><a class="header" href="#数据结构">数据结构</a></h1>
<h2 id="1-数据存储物理结构"><a class="header" href="#1-数据存储物理结构">1. 数据存储(物理)结构</a></h2>
<ul>
<li>
<h3 id="顺序"><a class="header" href="#顺序">顺序</a></h3>
<p>把逻辑上相邻的结点按顺序存储在物理上相邻的连续存储单元中，结点逻辑关系由存储单元的邻接关系体现。查找快，插入、删除慢。</p>
</li>
<li>
<h3 id="链式"><a class="header" href="#链式">链式</a></h3>
<p>用一组任意的存储单元存储逻辑上相邻的结点（存储单元可以连续也可以不连续），逻辑关系记录在指针域中。查找慢，插入、删除快。</p>
</li>
<li>
<h3 id="哈希散列"><a class="header" href="#哈希散列">哈希(散列)</a></h3>
<p>根据存储数据的内容计算哈希值来决定存储地址，根据内容查找时快</p>
</li>
<li>
<h3 id="索引"><a class="header" href="#索引">索引</a></h3>
<p>另外设置一个索引表来存储结点的地址，分开存放数据结点和结点逻辑关系</p>
</li>
</ul>
<h2 id="2-数据逻辑结构"><a class="header" href="#2-数据逻辑结构">2. 数据逻辑结构</a></h2>
<ul>
<li>
<h3 id="集合"><a class="header" href="#集合">集合</a></h3>
<p>无序、不重复的元素构成集合</p>
</li>
<li>
<h3 id="线性"><a class="header" href="#线性">线性</a></h3>
<p>具有唯一前驱和唯一后继的“一对一”关系的有序线性结构</p>
</li>
<li>
<h3 id="树形"><a class="header" href="#树形">树形</a></h3>
<p>具有唯一前驱但可以有一个或多个后继的“一对多”关系的树形结构</p>
</li>
<li>
<h3 id="图形"><a class="header" href="#图形">图形</a></h3>
<p>具有多个前驱和多个后继的“多对多”关系的图形结构</p>
</li>
</ul>
<h2 id="3-表堆栈和队列"><a class="header" href="#3-表堆栈和队列">3. 表、堆、栈和队列</a></h2>
<ul>
<li>
<h3 id="表"><a class="header" href="#表">表</a></h3>
<p>具有线性逻辑结构的就是线性表简称表，线性表又根据不同的物理实现方式分为：顺序表、链表。</p>
</li>
<li>
<h3 id="堆"><a class="header" href="#堆">堆</a></h3>
<p>堆是一种经过排序的树形结构。根结点最大的，父结点比子结点大的叫最大堆；根结点最小的叫最小堆。</p>
</li>
<li>
<h3 id="栈"><a class="header" href="#栈">栈</a></h3>
<p>栈是只允许在栈顶进行插入和删除操作的特殊线性表，栈又根据不同的物理实现方式分为：顺序栈、链式栈。具有“后进先出”的特性</p>
</li>
<li>
<h3 id="队列"><a class="header" href="#队列">队列</a></h3>
<p>队列是只允许在队尾插入，在队首删除的特殊线性表，队列又根据不同的物理实现方式分为：顺序队列、链式队列。具有“先进先出”的特性</p>
</li>
</ul>
<h2 id="4-二叉树的深度"><a class="header" href="#4-二叉树的深度">4. 二叉树的深度</a></h2>
<p>当前结点的深度为左右子树深度较大的值+1</p>
<pre><code class="language-swift">class BinaryTreeNode&lt;T&gt; {
    var data: T
    var left: BinaryTreeNode?
    var right: BinaryTreeNode?
    init(_ data: T, _ left: BinaryTreeNode? = nil, _ right: BinaryTreeNode? = nil) {
        self.data = data
        self.left = left
        self.right = right
    }
}

func depth&lt;T&gt;(_ node: BinaryTreeNode&lt;T&gt;?) -&gt; Int {
    guard let node = node else { return 0 }

    let left = depth(node.left) + 1
    let right = depth(node.right) + 1

    return left &gt; right ? left : right
}

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="算法"><a class="header" href="#算法">算法</a></h1>
<h2 id="1-时间复杂度"><a class="header" href="#1-时间复杂度">1. 时间复杂度</a></h2>
<ul>
<li>
<h3 id="时间频度"><a class="header" href="#时间频度">时间频度</a></h3>
<p>算法中语句执行次数称为时间频度，记为T(n)</p>
</li>
<li>
<h3 id="时间复杂度-on"><a class="header" href="#时间复杂度-on">时间复杂度 O(n)</a></h3>
</li>
</ul>
<h2 id="2-空间复杂度"><a class="header" href="#2-空间复杂度">2. 空间复杂度</a></h2>
<p>评估执行程序所需要的存储空间</p>
<h2 id="3-排序算法"><a class="header" href="#3-排序算法">3. 排序算法</a></h2>
<p>这里都按从小到大的 &lt; 顺序来排列</p>
<ul>
<li>
<h3 id="冒泡"><a class="header" href="#冒泡">冒泡</a></h3>
<p>一次比较两个相邻元素，大的换到后面；遍历重复，确保也只能确保最后一个元素是最大的，前面除最后一个元素外仍可能是乱序；
舍弃最后一个重复以上步骤，确保倒数第二个是第二大，以此类推就能确保右侧都是已排序序列</p>
</li>
</ul>
<pre><code class="language-swift">func bubbleSort(_ array: inout [Int]) {
    for i in 0..&lt;array.count - 1 {
        for j in 0..&lt;array.count - 1 - i {
            if array[j] &gt; array[j+1] {
                let temp = array[j+1]
                array[j+1] = array[j]
                array[j] = temp
                //array.swapAt(j, j+1)
            }
        }
    }
}
</code></pre>
<ul>
<li>
<h3 id="选择"><a class="header" href="#选择">选择</a></h3>
<p>在右侧未排序序列中遍历找到最小元素，让其和未排序序列最前的元素交换，即追加到左侧已排序序列的末尾；重复以上步骤，每次在
剩下的未排序元素中找到最小的追加到已排序序列的末尾</p>
</li>
</ul>
<pre><code class="language-swift">func selectionSort(_ array: inout [Int]) {
    for i in 0..&lt;array.count {
        var minIndex = i
        for j in i..&lt;array.count {
            if array[j] &lt; array[minIndex] {
                minIndex = j
            }
        }
        let temp = array[i]
        array[i] = array[minIndex]
        array[minIndex] = temp
    }
}
</code></pre>
<ul>
<li>
<h3 id="插入"><a class="header" href="#插入">插入</a></h3>
<p>在右侧未排序序列中选择最前的元素，让其和左侧已排序序列中元素从后到前遍历依次比较，一次比较两个相邻元素，小的换到前面；
重复以上步骤，每次在未排序序列中选择最前的元素插入到已排序序列的应有位置使其仍然是已排序的序列</p>
</li>
</ul>
<pre><code class="language-swift">func insertionSort(_ array: inout [Int]) {
    for i in 0..&lt;array.count {
        for j in (0..&lt;i).reversed() {
            if array[j+1] &lt; array[j] {
                let temp = array[j]
                array[j] = array[j+1]
                array[j+1] = temp
            }
        }
    }
}
</code></pre>
<h2 id="4-查找算法"><a class="header" href="#4-查找算法">4. 查找算法</a></h2>
<h2 id="5-反转"><a class="header" href="#5-反转">5. 反转</a></h2>
<ul>
<li>
<h3 id="数组-1"><a class="header" href="#数组-1">数组</a></h3>
<p>前后两个指针分别指向开始和结尾，交换，接着前指针后移，后指针前移；直到两指针相遇（偶数个元素）或者前指针在后指针的后面（奇数个元素），
也就是要保证前指针在后指针的前面，才可以进行循环</p>
</li>
</ul>
<pre><code class="language-swift">func reverse&lt;T&gt;(_ base: inout [T]) {
    var start = 0
    var end = base.count - 1
    while start &lt; end {
        let temp = base[start]
        base[start] = base[end]
        base[end] = temp
        start += 1
        end -= 1
    }
}
</code></pre>
<ul>
<li>
<h3 id="字符串"><a class="header" href="#字符串">字符串</a></h3>
<p>原理相同，只不过在swift中String不能直接进行下标访问，需要写一个extension</p>
</li>
</ul>
<pre><code class="language-swift">func reverse(_ string: inout String) {
    var start = 0
    var end = string.count - 1
    while start &lt; end {
        let temp = string[start]
        string[start] = string[end]
        string[end] = temp
        start += 1
        end -= 1
    }
}

extension String {
    func index(_ i: Int) -&gt; Self.Index {
        self.index(self.startIndex, offsetBy: i)
    }
    
    subscript(_ i: Int) -&gt; Character {
        get {
            self[self.index(i)]
        }
        set {
            self.remove(at: self.index(i))
            self.insert(newValue, at: self.index(i))
        }
    }
}
</code></pre>
<ul>
<li>
<h3 id="链表"><a class="header" href="#链表">链表</a></h3>
<p>设置一个新的头结点，遍历旧链表把每一个结点按顺序前插到新的链表中完成反转；使用可选项绑定来判空，首先临时保存当前结点的下一个结点，
将当前结点前插到新链表中时，next指向发生变化，所以必须先保存next；接着使current后移完成遍历，新头结点前移等待下一次前插；最终
新头结点为新链表的头结点</p>
</li>
</ul>
<pre><code class="language-swift">class LinkNode&lt;T&gt; {
    var data: T
    var next: LinkNode?
    init(_ data: T, _ next: LinkNode? = nil) {
        self.data = data
        self.next = next
    }
}

func reverse&lt;T&gt;(_ head: LinkNode&lt;T&gt;?) -&gt; LinkNode&lt;T&gt;? {
    var current = head
    var newHead: LinkNode&lt;T&gt;? = nil
    while let cur = current {
        let temp = cur.next
        cur.next = newHead
        current = temp
        newHead = cur
    }
    return newHead
}
</code></pre>
<h2 id="6-合并有序数组"><a class="header" href="#6-合并有序数组">6. 合并有序数组</a></h2>
<p>使用两个指针分别指向两个数组，当两个指针都在数组范围内时，结果数组追加两个数组中更小的一个元素，追加了谁谁的指针就后移；
当两个指针中有一个溢出就不可再继续了，代码中数组访问会报错；分别使用两个循环追加剩下的元素，不用关心谁有剩余，谁有剩余谁追加，没有剩余循环就退出</p>
<pre><code class="language-swift">func merge(_ array1: [Int], _ array2: [Int]) -&gt; [Int] {
    var p = 0
    var q = 0
    var result = [Int]()
    while p &lt; array1.count &amp;&amp; q &lt; array2.count {
        if array1[p] &lt;= array2[q] {
            result.append(array1[p])
            p += 1
        } else {
            result.append(array2[q])
            q += 1
        }
    }
    
    while p &lt; array1.count {
        result.append(array1[p])
        p += 1
    }
    while q &lt; array2.count {
        result.append(array2[q])
        q += 1
    }
    return result
}
</code></pre>
<h2 id="7-哈希计数查找"><a class="header" href="#7-哈希计数查找">7. 哈希计数查找</a></h2>
<p>查找第一个只出现一次的元素，哈希计数，遍历输入的序列，如果元素是第一次出现就把它的计数设为1，如果不是第一次出现就计数+1；
重新遍历，第一次找到哈希计数为一次的就反回结果；输入的序列可以是字符串或数组，序列中的元素要遵循哈希协议，这里的哈希实现
使用字典；字典返回的为可选项，当字典中没有关键字对应的值时返回nil，可选项绑定判空来判断是否是第一次出现</p>
<pre><code class="language-swift">func hashCount&lt;T: Sequence&gt;(_ sequence: T) -&gt; T.Element? where T.Element: Hashable {
    var dict = [T.Element: Int]()
    for element in sequence {
        guard let value = dict[element] else { dict[element] = 1; continue }
        dict[element] = value + 1
    }

    for element in sequence {
        if dict[element] == 1 {
            return element
        }
    }
    return nil
}
</code></pre>
<h2 id="8-用有序字典实现-lru缓存"><a class="header" href="#8-用有序字典实现-lru缓存">8. 用有序字典实现 LRU缓存</a></h2>
<pre><code class="language-swift">// 双向链表结点
class DoubleLinkedNode&lt;Data&gt; {
    var data: Data?
    var prev: DoubleLinkedNode?
    var next: DoubleLinkedNode?

    init(_ data: Data? = nil) {
        self.data = data
        self.prev = nil
        self.next = nil
    }
}

// 双向链表
// tips: 双向链表的优点主要在于删除快，不需要遍历一遍找到待删除结点的前一个结点
class DoubleLinkedList&lt;Data&gt; {
    // 虚拟头尾结点
    var head: DoubleLinkedNode&lt;Data&gt;
    var tail: DoubleLinkedNode&lt;Data&gt;

    // 链表结点个数
    var count: Int

    init() {
        self.head = DoubleLinkedNode()
        self.tail = DoubleLinkedNode()

        self.head.next = self.tail
        self.tail.prev = self.head

        self.count = 0
    }

    // 在虚拟头结点之后插入新结点，即在链表的第一个位置插入结点
    func insertFirst(_ newNode: DoubleLinkedNode&lt;Data&gt;) {
        self.insert(newNode, after: self.head)
    }

    // 删除虚拟尾结点的前一个结点，即删除链表最后一个位置的结点，并返回结点的引用
    func removeLast() -&gt; DoubleLinkedNode&lt;Data&gt;? {
        guard let last = tail.prev else { return nil }
        self.remove(last)
        return last
    }

    // 把某个结点移动到链表的第一个位置
    func moveToFirst(_ node: DoubleLinkedNode&lt;Data&gt;) {
        // 先删掉它，再在第一个位置插入
        self.remove(node)
        self.insertFirst(node)
    }

    // 在某个结点之后插入新的结点
    func insert(_ newNode: DoubleLinkedNode&lt;Data&gt;, after prevNode: DoubleLinkedNode&lt;Data&gt;) {
        guard let nextNode = prevNode.next else { return }

        // 新结点的前指针指向新结点前面的结点，新结点后面的结点的前指针指向新结点
        newNode.prev = prevNode
        nextNode.prev = newNode

        // 新结点的后指针指向新结点后面的结点，新结点前面的结点的后指针指向新结点
        newNode.next = nextNode
        prevNode.next = newNode

        // 插入计数 + 1
        self.count += 1
    }

    // 删除结点
    func remove(_ node: DoubleLinkedNode&lt;Data&gt;) {
        guard let prevNode = node.prev, let nextNode = node.next else { return }

        // 待删除结点的后一个结点的前指针指向待删除结点的前一个结点，待删除结点的前一个结点的后指针指向待删除结点的后一个结点
        nextNode.prev = node.prev
        prevNode.next = node.next

        // 删除计数 - 1
        self.count -= 1
    }
}

// 键值对
struct KeyValue&lt;Key, Value&gt; {
    var key: Key
    var value: Value
}

// 双向链表 + 哈希表
// 用哈希字典存储链表的结点引用，可以根据 key 键找到哈希字典中的链表结点引用进而找到链表中存储的 value 值
// 本来哈希字典是没有顺序的，与链表结合可以创造有序字典
class LinkedHashList&lt;Key: Hashable, Value&gt;: DoubleLinkedList&lt;KeyValue&lt;Key, Value&gt;&gt; {
    // 哈希字典 [键: 结点引用]
    var dict: [Key: DoubleLinkedNode&lt;KeyValue&lt;Key, Value&gt;&gt;]

    override init() {
        self.dict = Dictionary()
        super.init()
    }

    subscript(key: Key) -&gt; Value? {
        // key -&gt; node -&gt; value
        get {
            guard let node = self.dict[key] else { return nil }
            guard let data = node.data else { return nil }
            return data.value
        }

        set {
            // newValue 不为 nil 时
            if let newValue = newValue {
                // 已经有键时，修改链表结点的值
                if let node = self.dict[key] {
                    node.data?.value = newValue
                }
                // 没有键时，新建结点，设置哈希字典键对应的结点索引，并把结点插入到链表的第一个位置
                else {
                    let newNode = DoubleLinkedNode&lt;KeyValue&lt;Key, Value&gt;&gt;(KeyValue(key: key, value: newValue))
                    self.dict[key] = newNode
                    self.insertFirst(newNode)
                }
            }
            // newValue 为 nil 时，删除哈希字典索引，并删除链表中的结点 
            else {
                guard let node = self.dict[key] else { return }
                self.dict[key] = nil
                self.remove(node)
            }
        }
    }
 
    // 根据关键字，把某个结点移动到链表的第一个位置
    func moveToFirst(key: Key) {
        guard let node = self.dict[key] else { return }
        self.moveToFirst(node)
    }

    // 删除链表最后一个位置的结点，并把删除哈希字典索引
    func removeLast() { 
        guard let removedNode = super.removeLast() else { return }
        guard let data = removedNode.data else { return }
        self.dict[data.key] = nil
    }
}

// Least Recently Used，最少使用缓存算法
// 设置缓存最大容量，当缓存到达最大容量时，删除最少使用的缓存
class LRUCache&lt;Key: Hashable, Value&gt;: LinkedHashList&lt;Key, Value&gt; {
    // 容量
    var capacity: Int

    init(_ capacity: Int) {
        self.capacity = capacity
    }

    // 获取缓存
    func get(key: Key) -&gt; Value? {
        // 使用过移动到最前
        self.moveToFirst(key: key)
        return self[key]
    }

    // 设置缓存
    func set(key: Key, value: Value) {
        // 使用过移动到最前，如果新建结点，默认插入到最前所以不需要移动到最前
        if let _ = self[key] {
            self.moveToFirst(key: key)
        }
        self[key] = value

        // 超出最大容量时，删除最后面的使用最少的缓存
        if self.count &gt; self.capacity {
            self.removeLast()
        }
    }
}
</code></pre>
<h2 id="swift字符串算法特殊处理"><a class="header" href="#swift字符串算法特殊处理">Swift字符串算法特殊处理</a></h2>
<p>避免String为兼容utf-8而产生的繁琐下标方法，以及因此带来的性能损失</p>
<pre><code class="language-swift">var stringArray = [Character](&quot;abc&quot;)
print(stringArray[0]) // a
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift"><a class="header" href="#swift">Swift</a></h1>
<h2 id="1-copy"><a class="header" href="#1-copy">1. copy</a></h2>
<pre><code class="language-swift">class A: NSCopying {
    var a = 1
    func copy(with zone: NSZone? = nil) -&gt; Any {
        let cp = A()
        cp.a = a
        return cp
    }
}

let a = A()
let cp = a.copy() as! A

a.a = 2
print(a.a, cp.a)
</code></pre>
<h2 id="2-mutating"><a class="header" href="#2-mutating">2. mutating</a></h2>
<pre><code class="language-swift">struct A {
    var a = 1
    
    mutating func changeA() {
        a = 2
    }
}

var a = A()
a.changeA()
print(a.a)
</code></pre>
<h2 id="3-柯里化"><a class="header" href="#3-柯里化">3. 柯里化</a></h2>
<pre><code class="language-swift">func addTo(_ x: Int) -&gt; (Int) -&gt; Int {
    return { y in
        return x + y
    }
}

let addTo3 = addTo(3)
addTo3(4)
addTo3(5)
</code></pre>
<h2 id="4-常用高阶函数"><a class="header" href="#4-常用高阶函数">4. 常用高阶函数</a></h2>
<pre><code class="language-swift">//map映射
let mapResult = [0,1,2,3].map { (i) -&gt; String in
    return &quot;\(i)&quot;
}
print(mapResult)//[&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;]


//compactMap丢弃nil映射
let compactMapResult = [&quot;0&quot;,&quot;@&quot;,&quot;1&quot;,&quot;#&quot;,&quot;2&quot;,&quot;3&quot;].compactMap { (s) -&gt; Int? in
    return Int(s)
}
print(compactMapResult)//[0, 1, 2, 3]


//filter过滤器
let filterResult = [0,1,2,3].filter { (i) -&gt; Bool in
    return i % 2 == 0
}
print(filterResult)//[0, 2]


//reduce合并
let reduceResult = [0,1,2,3].reduce(0) { (re, i) -&gt; Int in
    return re + i
}
print(reduceResult)//6
</code></pre>
<h2 id="5-defer"><a class="header" href="#5-defer">5. defer</a></h2>
<p>延时执行，会在其所在作用域内所有语句执行完毕再执行
可以使得数据库连接、文件连接等关闭语句不一定非要写到作用域尾部，可以使用defer关键字和建立连接写到一起</p>
<pre><code class="language-swift">func f() {
    defer {
        print(2)
    }
    print(1)
}

f()//   1\n 2\n
</code></pre>
<h2 id="6-associatedtype"><a class="header" href="#6-associatedtype">6. associatedtype</a></h2>
<p>协议的泛型</p>
<pre><code class="language-swift">protocol P {
    associatedtype A
    var p: A { get set }
    func changeP() -&gt; A
}

class C1: P {
    typealias A = Int
    
    var p: Int = 1
    
    func changeP() -&gt; Int {
        p = 2
        return p
    }
}

class C2: P {
    typealias A = String
    
    var p: String = &quot;a&quot;
    
    func changeP() -&gt; String {
        p = &quot;b&quot;
        return p
    }
}

let c1 = C1()
c1.changeP()
let c2 = C2()
c2.changeP()
</code></pre>
<h2 id="7-final"><a class="header" href="#7-final">7. final</a></h2>
<p>限制继承和重写</p>
<pre><code class="language-swift">//final限制继承
final class FinalClass {

}
//class SubClass: FinalClass {}  //编译错误，无法继承final class
</code></pre>
<h2 id="8-访问控制"><a class="header" href="#8-访问控制">8. 访问控制</a></h2>
<ul>
<li>open</li>
<li>public</li>
<li>internal</li>
<li>file-private</li>
<li>private</li>
</ul>
<ol>
<li>open 在其它模块中可以访问和重写</li>
<li>public 在其它模块中可以访问，但不可以重写</li>
<li>internal 默认，在模块内部的多个文件内可以访问和重写</li>
<li>file-private 在文件内部可以访问</li>
<li>private 在类或结构体的内部可以访问</li>
</ol>
<h2 id="9-try-try"><a class="header" href="#9-try-try">9. try! try?</a></h2>
<pre><code class="language-swift">//try!  try?
func devide(_ a: Double, _ b: Double) throws -&gt; Double {
    enum DevideError: Error {
        case ZeroError
    }
    guard b != Double(0) else {
        throw DevideError.ZeroError
    }
    return a / b
}
print(try? devide(2, 1))//Optional(2.0)
//print(try! devide(2, 0))   //Fatal error崩溃退出
</code></pre>
<h2 id="10-autoclosure"><a class="header" href="#10-autoclosure">10. @autoclosure</a></h2>
<pre><code class="language-swift">//autoclosure把传进来的参数自动加上个闭包
func logIfTrue(_ predict: @autoclosure () -&gt; Bool) {
    if predict() {
        print(&quot;True&quot;)
    }
}
logIfTrue(2 &gt; 1)
</code></pre>
<h2 id="11-escaping"><a class="header" href="#11-escaping">11. @escaping</a></h2>
<pre><code class="language-swift">import Foundation

//  逃逸闭包，在闭包所在的函数体执行完毕之后执行的闭包
func delay(callback: @escaping (Timer) -&gt; Void) {
    Timer(timeInterval: 1, repeats: false, block: callback).fire()
}

delay { _ in
    print(&quot;escaping after 1 second&quot;)
}
</code></pre>
<h2 id="12-discardableresult"><a class="header" href="#12-discardableresult">12. @discardableResult</a></h2>
<pre><code class="language-swift">//在函数前加上@discardableResult，即使返回值没有被使用，编译器也不会提示
@discardableResult
func discardResult() -&gt; Int {
    return 1
}
discardResult()
</code></pre>
<h2 id="13-枚举关联值"><a class="header" href="#13-枚举关联值">13. 枚举关联值</a></h2>
<pre><code class="language-swift">enum Person {
    case man(name:String)
    case woman(name: String)
}

func whatName(_ person: Person) {
    switch person {
    case let .man(name: name):
        print(&quot;man&quot;, name)
    case let .woman(name: name):
        print(&quot;woman&quot;, name)
    }
}

whatName(.man(name: &quot;1&quot;)) // man 1
whatName(.woman(name: &quot;2&quot;)) // woman 2
</code></pre>
<h2 id="14-枚举封装"><a class="header" href="#14-枚举封装">14. 枚举封装</a></h2>
<pre><code class="language-swift">enum Week {
    case Monday
    case Tuesday
    case Whitch(Int)
    func printDay() {
        switch self {
        case .Monday:
            print(1)
        case .Tuesday:
            print(2)
        case .Whitch(let i):
            print(i)
        }
    }
}
Week.Monday.printDay()
Week.Tuesday.printDay()
Week.Whitch(1).printDay()
</code></pre>
<h2 id="15-操作列表"><a class="header" href="#15-操作列表">15. 操作列表</a></h2>
<pre><code class="language-swift">//[.option1, .option2]
enum Option {
    case option1
    case option2
}
typealias Options = [Option]
func setOptions(_ options: Options) {
    struct ParsedOptions {
        var option1 = false
        var option2 = false
        init(_ options: Options) {
            for op in options {
                switch op {
                case .option1:
                    option1 = true
                case .option2:
                    option2 = true
                }
            }
        }
    }
    print(ParsedOptions(options))
}
setOptions([.option1, .option2])
</code></pre>
<h2 id="16-"><a class="header" href="#16-">16. ??</a></h2>
<pre><code class="language-swift">//?? Optional默认值
let defaultNilValue = Int(&quot;@&quot;) ?? 0
print(defaultNilValue)
</code></pre>
<h2 id="17-propertywrapper"><a class="header" href="#17-propertywrapper">17. @propertyWrapper</a></h2>
<pre><code class="language-swift">//  用属性包装器来包裹
@propertyWrapper
struct AddOne {
    private var x: Int
    
    init() {
        x = 0
    }
    
    var wrappedValue: Int {
        get {
            x + 1
        }
        
        set {
            x = newValue
        }
    }
}

//  属性包装器不能写在模块顶层
struct Test {
    @AddOne var addOne: Int
}
var test = Test()
print(test.addOne) // 1
test.addOne = 1
print(test.addOne) // 2
</code></pre>
<h2 id="18-keypath"><a class="header" href="#18-keypath">18. keyPath</a></h2>
<pre><code class="language-swift">struct A {
    struct B {
        struct C {
            let value: String = &quot;c&quot;
        }
        let value: C = C()
    }
    let value: B = B()
    var c: String {
        get {
            self[keyPath: \.value.value.value]
        }
    }
    func keyPath(_ keyPath: KeyPath&lt;A, String&gt;) -&gt; String {
        return self[keyPath: keyPath]
    }
}

let a = A()
a.value.value.value
let keyPath = \A.value.value.value
a[keyPath: keyPath]
a.keyPath(\.value.value.value)
a.c
</code></pre>
<h2 id="19-元素为值类型和引用类型的数组更改的区别"><a class="header" href="#19-元素为值类型和引用类型的数组更改的区别">19. 元素为值类型和引用类型的数组更改的区别</a></h2>
<pre><code class="language-swift">// 元素为值类型的数组只可以使用index更改数组

struct Value {
    var property = 0
}

var valueArray: [Value] = .init(repeating: .init(), count: 3)

for index in 0..&lt;valueArray.count {
    valueArray[index].property += 1
}

dump(valueArray)
</code></pre>
<pre><code class="language-swift">// 元素为引用类型的数组既可以使用index更改数组，又可以使用for-in循环更改数组
class Reference {
    var property = 0
}

// 引用类型元素不可以使用Array(repeating:count:)来循环创建数组，否则创建出来的数组都是同一个引用
//var referenceArray: [Reference] = .init(repeating: .init(), count: 3)
var referenceArray: [Reference] = .init(AnyIterator(Reference.init).prefix(3))

for reference in referenceArray {
    reference.property += 1
}

for index in 0..&lt;referenceArray.count {
    referenceArray[index].property += 1
}

dump(referenceArray)
</code></pre>
<h2 id="20-字典key和value同时映射"><a class="header" href="#20-字典key和value同时映射">20. 字典key和value同时映射</a></h2>
<pre><code class="language-swift">extension Dictionary {
    func mapKeysAndValues&lt;K, V&gt;(_ transform: ((key: Key, value: Value)) throws -&gt; (K, V)) rethrows -&gt; [K: V] {
        [K: V](uniqueKeysWithValues: try map(transform))
    }
}
</code></pre>
<h2 id="21-_dynamicreplacement"><a class="header" href="#21-_dynamicreplacement">21. @_dynamicReplacement</a></h2>
<pre><code class="language-swift">class B {
    dynamic func a() {
        print(&quot;a&quot;)
    }
}

extension B {
    @_dynamicReplacement(for:a)
    func c() {
        print(&quot;b&quot;)
    }
}

B().a()
</code></pre>
<h2 id="22-范型与协议共用时有可能会遇到丧失范型类型的情况"><a class="header" href="#22-范型与协议共用时有可能会遇到丧失范型类型的情况">22. 范型与协议共用时有可能会遇到丧失范型类型的情况</a></h2>
<pre><code class="language-swift">protocol P {
    var a: Int { get }
}

extension P {
    var a: Int {
        0
    }
}

struct T&lt;M&gt;: P {
    
}

extension T where M == Int {
    var a: Int {
        1
    }
}

let t: P = T&lt;Int&gt;()
print(t.a) // 0 丧失类型T&lt;Int&gt;，变为P
print(T&lt;Int&gt;().a) // 1
</code></pre>
<pre><code class="language-swift">protocol P {
    var a: Int { get }
}

extension P {
    var a: Int {
        0
    }
}

struct T: P {
    var a: Int {
        1
    }
}

let t: P = T()
print(t.a) // 1 不会丧失类型
print(T().a) // 1
</code></pre>
<h2 id="23-切片slice是绝对索引而不是相对索引"><a class="header" href="#23-切片slice是绝对索引而不是相对索引">23. 切片slice是绝对索引而不是相对索引</a></h2>
<pre><code class="language-swift">print([0, 1, 2][1...].startIndex) // 1
print((1..&lt;3).startIndex) // 1
print([0, 1, 2][1...][0]) // Fatal error: Index out of bounds
print((1..&lt;3)[0]) //  Fatal error: Index out of range
</code></pre>
<h2 id="24-类单例和结构体单例"><a class="header" href="#24-类单例和结构体单例">24. 类单例和结构体单例</a></h2>
<pre><code class="language-swift">class C {
    static let shared = C()

    var state = 0
}

struct T {
    static var shared = T()

    var state = 0
}

// 将shared赋值给其它变量的情况

let c = C.shared
c.state = 1
print(C.shared.state) // 1

var t = T.shared
t.state = 1
print(T.shared.state) // 0 没有改变

// 使用类名/结构体名直接调用的情况

C.shared.state = 2
T.shared.state = 2
print(C.shared.state) // 2
print(T.shared.state) // 2
</code></pre>
<h2 id="25-decimal解决浮点数运算比较问题"><a class="header" href="#25-decimal解决浮点数运算比较问题">25. Decimal解决浮点数运算比较问题</a></h2>
<pre><code class="language-swift">print((0.1 + 0.2) == 0.3) // false
print(Decimal(0.1) + Decimal(0.2) == Decimal(0.3)) // true
print(Double(truncating: (Decimal(0.1) + Decimal(0.2)) as NSNumber)) // 0.3
</code></pre>
<h2 id="26-库前缀名调用"><a class="header" href="#26-库前缀名调用">26. 库前缀名调用</a></h2>
<pre><code class="language-swift">public struct Reactive&lt;Base&gt; {
    public let base: Base
    
    init(_ base: Base) {
        self.base = base
    }
}

public protocol ReactiveCompatible {
    associatedtype ReactiveBase
    
    var rx: Reactive&lt;ReactiveBase&gt; { get }
}

extension ReactiveCompatible {
    public var rx: Reactive&lt;Self&gt; {
        Reactive(self)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">String</a></h1>
<h2 id="1-str0"><a class="header" href="#1-str0">1. str[0]</a></h2>
<pre><code class="language-swift">//  扩展字符串使它可以像其他语言一样以下标方式修改获取字符
extension String {
    
    //  String中的每个字符元素并不是等长的，而是由1~4个UTF-8组成，因此不能直接使用Int来索引
    func index(_ i: Int) -&gt; Index {
        //  根据首索引和偏移计算出真实的索引
        self.index(self.startIndex, offsetBy: i)
    }
    
    subscript(_ i: Int) -&gt; Character {
        set(newValue) {
            self.remove(at: self.index(i))
            self.insert(newValue, at: self.index(i))
        }
        get {
            return self[self.index(i)]
        }
    }
}
</code></pre>
<h2 id="2-split"><a class="header" href="#2-split">2. split</a></h2>
<pre><code class="language-swift">//  split分割
let sentence = &quot;hello, my name is eric&quot;
let words = sentence.split(separator: &quot; &quot;)
print(words)
</code></pre>
<h2 id="3-join"><a class="header" href="#3-join">3. join</a></h2>
<pre><code class="language-swift">//  joined拼接
let words = [&quot;hello,&quot;, &quot;my&quot;, &quot;name&quot;, &quot;is&quot;, &quot;liuzihao&quot;]
let sentence = words.joined(separator: &quot; &quot;)
print(sentence)
</code></pre>
<h2 id="4-contains"><a class="header" href="#4-contains">4. contains</a></h2>
<pre><code class="language-swift">//  是否包含
&quot;abc&quot;.contains(&quot;a&quot;)
</code></pre>
<h2 id="5-大小写"><a class="header" href="#5-大小写">5. 大小写</a></h2>
<pre><code class="language-swift">&quot;abcd&quot;.uppercased()

&quot;ABCD&quot;.lowercased()
</code></pre>
<h2 id="6-unicode"><a class="header" href="#6-unicode">6. unicode</a></h2>
<pre><code class="language-swift">&quot;abcd&quot;.unicodeScalars.forEach { (unicode) in
    print(unicode.value)
}
</code></pre>
<h2 id="7-substring"><a class="header" href="#7-substring">7. substring</a></h2>
<pre><code class="language-swift">//  前几位子字符串
&quot;abcd&quot;.prefix(2)//  ab
//  后几位子字符串
&quot;accd&quot;.suffix(2)//  cd
</code></pre>
<h2 id="swift-string-length"><a class="header" href="#swift-string-length">Swift String Length</a></h2>
<p><code>String.count</code>得到的是<code>Unicode.Scalar</code>按Unicode规则合成<code>Character</code>后，<code>String</code>中<code>Character</code>的个数。
&quot;\r&quot;和&quot;\n&quot;两个字符合成了新的单个字符&quot;\r\n&quot;，因此字符串长度为1</p>
<pre><code class="language-swift">&quot;\r\n&quot;.count // 1
strlen(&quot;\r\n&quot;) // 2
&quot;\r\n&quot;.unicodeScalars.count // 2

(&quot;🇨&quot; + &quot;🇳&quot;) == &quot;🇨🇳&quot; // true
(&quot;🇨&quot; + &quot;🇳&quot;).count // 1
&quot;🇨🇳&quot;.unicodeScalars.count // 2
</code></pre>
<h3 id="使用utf8和c函数一起工作"><a class="header" href="#使用utf8和c函数一起工作">使用utf8和C函数一起工作</a></h3>
<pre><code class="language-swift">strlen(&quot;你好&quot;) // 6
&quot;你好&quot;.utf8.count // 6
</code></pre>
<h3 id="使用utf16和objective-c函数一起工作"><a class="header" href="#使用utf16和objective-c函数一起工作">使用utf16和Objective-C函数一起工作</a></h3>
<pre><code class="language-swift">NSString(string: &quot;你好&quot;).length // 2
&quot;你好&quot;.utf16.count // 2
</code></pre>
<h3 id="utf8cstring"><a class="header" href="#utf8cstring">utf8CString</a></h3>
<pre><code class="language-swift">strlen(&quot;abc&quot;) // 3 (长度不包含'\0')
&quot;abc&quot;.utf8CString // [97, 98, 99, 0]
&quot;abc&quot;.utf8CString.count // 4 (长度包含'\0')
</code></pre>
<h3 id="contains的巨坑"><a class="header" href="#contains的巨坑">contains的巨坑</a></h3>
<p>引入Foundation之前，contains调用的是Swift标准库；引入之后，contains调用的是Foundation中NSString的方法。
Swift完全支持Unicode，而Objective-C只支持utf-16，造成了引入前后不一样的结果</p>
<pre><code class="language-swift">&quot;\r\n&quot;.contains(&quot;\n&quot;) // false
&quot;🇨🇳&quot;.contains(&quot;🇨&quot;) // false
</code></pre>
<pre><code class="language-swift">import Foundation

&quot;\r\n&quot;.contains(&quot;\n&quot;) // true
&quot;🇨🇳&quot;.contains(&quot;🇨&quot;) // true
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="foundation"><a class="header" href="#foundation">Foundation</a></h1>
<h2 id="蛇形json解析自动转换为驼峰"><a class="header" href="#蛇形json解析自动转换为驼峰">蛇形JSON解析自动转换为驼峰</a></h2>
<pre><code class="language-swift">struct Hello: Decodable {
    var camelSnake: Int
}

let decoder = JSONDecoder()
decoder.keyDecodingStrategy = .convertFromSnakeCase
let hello = try! decoder.decode(Hello.self, from: &quot;{\&quot;camel_snake\&quot;: 1}&quot;.data(using: .utf8)!)
print(hello)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="uikit"><a class="header" href="#uikit">UIKit</a></h1>
<h2 id="1-uiview-和-calayer"><a class="header" href="#1-uiview-和-calayer">1. UIView 和 CALayer</a></h2>
<ul>
<li>UIView继承UIResponder，可以响应事件；</li>
<li>CALayer用来绘制内容；</li>
<li>UIView设置表现和位置时，内部实际是对所持有的layer的更改</li>
</ul>
<h2 id="2-frame-和-bounds"><a class="header" href="#2-frame-和-bounds">2. Frame 和 Bounds</a></h2>
<ul>
<li>在width和height上frame和bounds没有什么区别</li>
<li>frame设置控件在父控件坐标系中的位置；bounds更改控件自身的坐标系</li>
<li>默认坐标系是左上角为(0,0)，向右向下(x,y)变大，更改bounds的(x,y)可以改变坐标系左上角为(x,y)，
子控件自然随着控件自身坐标系的更改而改动位置</li>
</ul>
<h2 id="uitabbarcontroller"><a class="header" href="#uitabbarcontroller">UITabBarController</a></h2>
<pre><code class="language-swift">class TabBarController: UITabBarController, UITabBarControllerDelegate {
    init() {
        super.init(nibName: nil, bundle: nil)
        
        viewControllers = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map { text in
            ViewController(text: text)
        }
        
        delegate = self
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    func tabBarController(_ tabBarController: UITabBarController, didSelect viewController: UIViewController) {
        print(viewControllers?.firstIndex(of: viewController))
    }
}

class ViewController: UIViewController {
    init(text: String) {
        super.init(nibName: nil, bundle: nil)
        
        let label = UILabel(frame: .init(x: 100, y: 100, width: 100, height: 30))
        label.text = text
        
        view.addSubview(label)
        tabBarItem = UITabBarItem(title: text, image: nil, tag: 0)
    }
    
    required init?(coder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
}
</code></pre>
<h2 id="在swiftui中使用uikit的app生命周期"><a class="header" href="#在swiftui中使用uikit的app生命周期">在SwiftUI中使用UIKit的App生命周期</a></h2>
<pre><code class="language-swift">import SwiftUI

@main
struct DemoApp: App {
    @UIApplicationDelegateAdaptor var delegate: AppDelegate
    
    var body: some Scene {
        WindowGroup {
            DemoView()
        }
    }
}

class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey : Any]? = nil) -&gt; Bool {
        return true
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="webkit"><a class="header" href="#webkit">WebKit</a></h1>
<h2 id="1-js-和-swift-互相调用"><a class="header" href="#1-js-和-swift-互相调用">1. JS 和 swift 互相调用</a></h2>
<pre><code class="language-swift">import JavaScriptCore

let context: JSContext = JSContext()
context.evaluateScript(&quot;function sum(a,b) { return a+b }&quot;)
let result = context.evaluateScript(&quot;sum(1,1)&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="内存管理"><a class="header" href="#内存管理">内存管理</a></h1>
<h2 id="1-arc自动引用计数"><a class="header" href="#1-arc自动引用计数">1. ARC自动引用计数</a></h2>
<p>初始化类的时候会分配内存，ARC自动计数实例被引用的次数，当不再被引用的时候释放内存；
默认创建的引用为强引用，只有当c1,c2,c3都取消对实例的引用时才会释放为实例分配的内存</p>
<pre><code class="language-swift">class C {
    deinit {
        print(&quot;deinit&quot;)
    }
}

var c1: C?
var c2: C?
var c3: C?

c1 = C()
c2 = c1
c3 = c1

c1 = nil
c2 = nil
c3 = nil
</code></pre>
<h2 id="2-weak循环引用"><a class="header" href="#2-weak循环引用">2. weak循环引用</a></h2>
<p>互相持有会引起循环引用，导致ARC引用计数永不为空，无法释放内存；添加weak关键字使用弱引用即可解决这个问题</p>
<pre><code class="language-swift">class A {
    weak var b: B?
    deinit {
        print(&quot;deinit A&quot;)
    }
}

class B {
    var a: A?
    deinit {
        print(&quot;deinit B&quot;)
    }
}

var a: A?
var b: B?

a = A()
b = B()

a!.b = b
b!.a = a

a = nil
b = nil
</code></pre>
<h2 id="3-struct-和-class"><a class="header" href="#3-struct-和-class">3. struct 和 class</a></h2>
<ul>
<li>
<h3 id="struct是值类型"><a class="header" href="#struct是值类型">struct是值类型</a></h3>
</li>
</ul>
<p>基础类型Int,String,Array等都是值类型；存放于栈区，不可继承</p>
<ul>
<li>
<h3 id="class是引用类型"><a class="header" href="#class是引用类型">class是引用类型</a></h3>
</li>
</ul>
<p>存放于堆区，可继承</p>
<h2 id="4-深拷贝和浅拷贝"><a class="header" href="#4-深拷贝和浅拷贝">4. 深拷贝和浅拷贝</a></h2>
<ul>
<li>值类型深拷贝，像细胞分裂一样完全的复制一份出来</li>
</ul>
<pre><code class="language-swift">struct S {
    var s = 0
}

var s1 = S()
var s2 = s1
s1.s = 1
s2.s = 2
print(s1.s, s2.s)
</code></pre>
<ul>
<li>引用类型浅拷贝，仅复制对实例的引用，两个引用仍是同一个实例的引用</li>
</ul>
<pre><code class="language-swift">class C {
    var c = 0
}

let c1 = C()
let c2 = c1
c1.c = 1
c2.c = 2
print(c1.c, c2.c)
</code></pre>
<h2 id="5-参数传递"><a class="header" href="#5-参数传递">5. 参数传递</a></h2>
<ul>
<li>值类型默认值传递，会复制一份传入函数内，如果想要修改外部变量必须显示声明inout，且在调用的时候添加&amp;</li>
</ul>
<pre><code class="language-swift">struct S {
    var s = 0
}

func modify(_ s: inout S) {
    s.s = 1
}

var s = S()
modify(&amp;s)
print(s.s)
</code></pre>
<ul>
<li>引用类型默认引用传递，会传入实例的引用，可以直接修改外部的实例</li>
</ul>
<pre><code class="language-swift">class C {
    var c = 0
}

func modify(_ c: C) {
    c.c = 1
}

let c = C()
modify(c)
print(c.c)
</code></pre>
<h2 id="6-写时复制"><a class="header" href="#6-写时复制">6. 写时复制</a></h2>
<p>值类型数据在需要更改的时候才会真正的复制</p>
<h2 id="7-bad_access"><a class="header" href="#7-bad_access">7. BAD_ACCESS</a></h2>
<p>访问了已经释放的变量</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="网络"><a class="header" href="#网络">网络</a></h1>
<h2 id="1-七层网络协议"><a class="header" href="#1-七层网络协议">1. 七层网络协议</a></h2>
<ul>
<li>
<h3 id="物理层"><a class="header" href="#物理层">物理层</a></h3>
<p>集线器、中继器，传输比特流</p>
</li>
<li>
<h3 id="数据链路层"><a class="header" href="#数据链路层">数据链路层</a></h3>
<p>网桥、交换机，传输数据帧</p>
</li>
<li>
<h3 id="网络层"><a class="header" href="#网络层">网络层</a></h3>
<p>路由器，传输IP数据报；IP,ICMP,ARP</p>
</li>
<li>
<h3 id="传输层"><a class="header" href="#传输层">传输层</a></h3>
<p>网关；TCP,UDP</p>
</li>
<li>
<h3 id="会话层"><a class="header" href="#会话层">会话层</a></h3>
<p>管理主机之间的会话进程</p>
</li>
<li>
<h3 id="表示层"><a class="header" href="#表示层">表示层</a></h3>
<p>数据的加密、压缩、格式转换等</p>
</li>
<li>
<h3 id="应用层"><a class="header" href="#应用层">应用层</a></h3>
<p>FTP,Telnet,DNS,SMTP,HTTP</p>
</li>
</ul>
<h2 id="2-http-和-https"><a class="header" href="#2-http-和-https">2. http 和 https</a></h2>
<p>http明文传输，https加密传输；http:80，https:443</p>
<h2 id="3-三次握手-和-四次挥手"><a class="header" href="#3-三次握手-和-四次挥手">3. 三次握手 和 四次挥手</a></h2>
<h2 id="4-tcp-和-udp的区别"><a class="header" href="#4-tcp-和-udp的区别">4. TCP 和 UDP的区别</a></h2>
<p>TCP面向连接、传输可靠，用于传输大量数据（数据流模式），速度慢开销大
UDP面向非连接、传输不可靠，用于传输少量数据（数据包模式），速度快</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据存储"><a class="header" href="#数据存储">数据存储</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="多线程"><a class="header" href="#多线程">多线程</a></h1>
<h2 id="1-进程与线程"><a class="header" href="#1-进程与线程">1. 进程与线程</a></h2>
<ul>
<li>进程</li>
</ul>
<p>进程是指正在运行的一个应用程序，正在进行的程序；进程之间是独立的，拥有独立运行所需要的全部资源</p>
<ul>
<li>线程</li>
</ul>
<p>一个进程中可以有多个线程，至少有一个默认启动的线程即为主线程；同一个进程内的线程共享进程资源</p>
<h2 id="2-什么是多线程"><a class="header" href="#2-什么是多线程">2. 什么是多线程</a></h2>
<ul>
<li>同一时间内单核CPU只能执行一个线程，多线程是CPU快速在多个线程之间进行切换调度，造成的多个线程同时执行的假象；多核CPU可以真的多线程</li>
<li>多线程是为了同步完成多项任务</li>
</ul>
<h2 id="3-多线程的优点和缺点"><a class="header" href="#3-多线程的优点和缺点">3. 多线程的优点和缺点</a></h2>
<ul>
<li>优点</li>
</ul>
<p>适当提高程序的执行效率，适当提高资源利用率</p>
<ul>
<li>缺点</li>
</ul>
<p>开启线程需要内存空间，线程越多CPU的调度开销越大，线程之间的数据通信和共享更使得程序开发更加复杂</p>
<h2 id="4-并行-和-并发"><a class="header" href="#4-并行-和-并发">4. 并行 和 并发</a></h2>
<ul>
<li>并行：利用计算机的多核，在多个线程上同步进行</li>
<li>并发：在一条线程上快速切换，让人感觉在同步进行</li>
</ul>
<h2 id="5-多线程方案"><a class="header" href="#5-多线程方案">5. 多线程方案</a></h2>
<ul>
<li>Thread</li>
</ul>
<p>面向对象，需要手动创建但不需要手动销毁，线程通信困难</p>
<ul>
<li>GCD DispatchQueue</li>
</ul>
<p>充分利用设备多核，自动管理线程生命周期，比OperationQueue效率更高</p>
<ul>
<li>OperationQueue</li>
</ul>
<p>基于GCD的封装，更加面向对象</p>
<h2 id="6-thread"><a class="header" href="#6-thread">6. Thread</a></h2>
<pre><code class="language-swift">import Foundation

let c1 = NSCondition()
let c2 = NSCondition()

let t1 = Thread {
    for index in 1...5 {
        print(&quot;t1&quot;, index)
        
        //  t1输出两次之后开始等待
        if index == 2 {
            print(&quot;t1 waiting......&quot;)
            
            c1.lock()
            c1.wait()
            c1.unlock()
        }
    }
    
    //  t1输出完毕之后，通知t2继续
    c2.signal()
}
let t2 = Thread {
    for index in 1...5 {
        print(&quot;t2&quot;, index)
        
        //  t2输出三次之后开始等待，并通知t1继续
        if index == 3 {
            c1.signal()
            
            print(&quot;t2 waiting......&quot;)
            
            c2.lock()
            c2.wait()
            c2.unlock()
        }
    }
}

t1.start()
t2.start()

//  让主线程等待以看到所有输出，不然切换到主线程执行完毕就没有输出了
Thread.sleep(forTimeInterval: 10)
</code></pre>
<h2 id="7-gcd"><a class="header" href="#7-gcd">7. GCD</a></h2>
<p>串行队列：队列中的任务按顺序执行
并行队列：队列中的任务并行执行
同步：阻塞，等到执行完毕
异步：非阻塞</p>
<pre><code class="language-swift">//GCD

//异步回到主线程执行闭包，同步会死锁
DispatchQueue.main.async {
    print(&quot;main thread&quot;)
}


//异步串行执行闭包，保证queue内添加的闭包按添加顺序执行
let queue = DispatchQueue(label: &quot;com.queue&quot;)
queue.async {
    print(1)
}
queue.async {
    print(2)
}
queue.async {
    print(3)
}


//获取全局并行队列，异步并发执行闭包，不能保证闭包按顺序执行
DispatchQueue.global().async {
    print(1)
}
DispatchQueue.global().async {
    print(2)
}
DispatchQueue.global().async {
    print(3)
}


//异步延时执行
DispatchQueue.global().asyncAfter(deadline: .now() + DispatchTimeInterval.seconds(3)) {
    print(&quot;execute after 3 seconds&quot;)
}


//群组操作
let group = DispatchGroup()
DispatchQueue.global().async(group: group) {
    print(1)
}
DispatchQueue.global().async(group: group) {
    print(2)
}
DispatchQueue.global().async(group: group) {
    print(3)
}
group.notify(queue: .main) {
    print(&quot;all done&quot;)
}


//使用信号量同步执行异步并行队列的任务
let semaphore = DispatchSemaphore(value: 1)
for i in 0..&lt;5 {
    //wait semaphore-1
    if semaphore.wait(timeout: .distantFuture) == .success {
        DispatchQueue.global().async {
            print(i)
            //signal semaphore+1
            semaphore.signal()
        }
    }
}
</code></pre>
<h2 id="8-operationqueue"><a class="header" href="#8-operationqueue">8. OperationQueue</a></h2>
<pre><code class="language-swift">import Foundation

//  切换到主线程
OperationQueue.main.addOperation {
    print(&quot;main thread&quot;)
}

//  串行
let queue = OperationQueue()
queue.addBarrierBlock {
    print(1)
}
queue.addBarrierBlock {
    print(2)
}
queue.addBarrierBlock {
    print(3)
}

//  并行
let queueConcurrent = OperationQueue()
queueConcurrent.addOperation {
    print(1)
}
queueConcurrent.addOperation {
    print(2)
}
queueConcurrent.addOperation {
    print(3)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计模式-1"><a class="header" href="#设计模式-1">设计模式</a></h1>
<h2 id="1-单例模式"><a class="header" href="#1-单例模式">1. 单例模式</a></h2>
<pre><code class="language-swift">class Singleton {
    static let shared = Singleton()
}
</code></pre>
<h2 id="2-代理模式"><a class="header" href="#2-代理模式">2. 代理模式</a></h2>
<pre><code class="language-swift">//代理模式

//A的代理协议
protocol ADelegate {
    //回调
    func callBack(string: String)
}

//A类
class A {
    //A的代理
    var delegate: ADelegate?
    //执行A的函数
    func goBack() {
        if let delegate = delegate {
            //代理回调
            delegate.callBack(string: &quot;123&quot;)
        }
    }
}

//B类是A的代理实现
class B: ADelegate {
    init() {
        let a = A()
        //把B类对象作为a对象的代理
        a.delegate = self
        a.goBack()
    }

    //回调执行
    func callBack(string: String) {
        print(string)
    }
}
//B构造执行init
B()
</code></pre>
<h2 id="3-观察者模式"><a class="header" href="#3-观察者模式">3. 观察者模式</a></h2>
<p><a href="iOS/../CS/DesignPatterns.html#_1-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a></p>
<p>Key-Value Observing</p>
<pre><code class="language-swift">import Foundation

class Subject: NSObject {
    @objc dynamic var state = 0
}

class Observer: NSObject {
    override func observeValue(forKeyPath keyPath: String?,
                               of object: Any?,
                               change: [NSKeyValueChangeKey : Any]?,
                               context: UnsafeMutableRawPointer?) {
        print(change?[.newKey] as Any)
    }
}

let subject = Subject()
let observer = Observer()
subject.addObserver(observer, forKeyPath: &quot;state&quot;, options: .new, context: nil)
subject.state = 1
// print: Optional(1)
</code></pre>
<p>Notification</p>
<pre><code class="language-swift">import Foundation

let name = Notification.Name.init(&quot;event&quot;)
class ObjectA {}
class ObjectB {}

let objectA = ObjectA()
let objectB = ObjectB()

// NotificationCenter实际上是观察者模式中的被观察对象
let center = NotificationCenter.default

center.addObserver(forName: name, object: nil, queue: .main) { (notification) in
    print(&quot;我接收所有对象的通知&quot;, &quot;发送至\(notification.object ?? &quot;所有对象&quot;)&quot;)
}

center.addObserver(forName: name, object: objectA, queue: .main) { (notification) in
    print(&quot;我只接收A的通知&quot;, &quot;发送至\(notification.object ?? &quot;所有对象&quot;)&quot;)
}

center.post(name: name, object: nil)
center.post(name: name, object: objectA)
center.post(name: name, object: objectB)
// print: 我接收所有对象的通知 发送至所有对象
//        我接收所有对象的通知 发送至ObjectA
//        我只接收A的通知 发送至ObjectA
//        我接收所有对象的通知 发送至ObjectB
</code></pre>
<h2 id="4-工厂模式"><a class="header" href="#4-工厂模式">4. 工厂模式</a></h2>
<pre><code class="language-swift">//  工厂
class Factory {
    //  产品类型
    enum ProductType {
        case ProductA
        case ProductB
    }
    //  制造
    func make(type: ProductType) -&gt; Product {
        switch type {
        case .ProductA:
            return ProductA()
        case .ProductB:
            return ProductB()
        }
    }
}

//  产品协议
protocol Product {
    //  产品说明书
    func instructions()
}

//  产品A
class ProductA: Product {
    func instructions() {
        print(&quot;product A&quot;)
    }
}

//  产品B
class ProductB: Product {
    func instructions() {
        print(&quot;product B&quot;)
    }
}

let factory = Factory()
factory.make(type: .ProductA).instructions()
factory.make(type: .ProductB).instructions()
</code></pre>
<h2 id="5-装饰器模式"><a class="header" href="#5-装饰器模式">5. 装饰器模式</a></h2>
<pre><code class="language-swift">//  礼物
protocol Gift {
    //  惊喜
    func surprise()
}

//  玩具车
class ToyCar: Gift {
    func surprise() {
        print(&quot;a toy car&quot;)
    }
}

//  装饰器
class Decorator: Gift {
    private var decorated: Gift
    
    init(_ gift: Gift) {
        decorated = gift
    }
    
    func surprise() {
        decorated.surprise()
    }
}

//  礼物盒
class GiftBox: Decorator {
    override func surprise() {
        super.surprise()
        print(&quot;decorated with a gift box&quot;)
    }
}

GiftBox(ToyCar()).surprise()
</code></pre>
<h2 id="6-迭代器模式"><a class="header" href="#6-迭代器模式">6. 迭代器模式</a></h2>
<pre><code class="language-swift">protocol _Sequence {
    associatedtype Element
    associatedtype Iterator

    func makeIterator() -&gt; Self.Iterator
}

protocol _IteratorProtocal {
    associatedtype Element

    mutating func next() -&gt; Self.Element?
}

struct _Array&lt;Element&gt;: _Sequence {
    typealias Element = Element
    typealias Iterator = _Iterator&lt;Self&gt;

    let value: [Element]

    func makeIterator() -&gt; Self.Iterator {
        return _Iterator&lt;Self&gt;(value: value)
    }
}


struct _Iterator&lt;Elements&gt;: _IteratorProtocal where Elements: _Sequence {
    typealias Element = Elements.Element

    let value: [Element]
    var index: Int = 0

    mutating func next() -&gt; Elements.Element? {
        guard index &lt; value.count else { return nil }
        defer {
            index += 1
        }
        return value[index]
    }
}



var iter = _Array&lt;Int&gt;(value: [1, 2, 3, 4, 5]).makeIterator()
//var iter = _Array&lt;String&gt;(value: [&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;]).makeIterator()
while let item = iter.next() {
    print(item)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="并发编程"><a class="header" href="#并发编程">并发编程</a></h1>
<h2 id="异步函数的定义和调用"><a class="header" href="#异步函数的定义和调用">异步函数的定义和调用</a></h2>
<pre><code class="language-swift">func hello(_ number: Int) async -&gt; Int {
    await Task.sleep(1_000_000_000)
    print(&quot;Hello Concurrency! \(number)&quot;)
    
    return number
}

let n = await hello(0)
print(n)
</code></pre>
<h2 id="串行"><a class="header" href="#串行">串行</a></h2>
<pre><code class="language-swift">let n0 = await hello(0)
let n1 = await hello(1)
let n2 = await hello(2)

print(n0 + n1 + n2)
</code></pre>
<h2 id="并行"><a class="header" href="#并行">并行</a></h2>
<pre><code class="language-swift">async let n3 = hello(3)
async let n4 = hello(4)
async let n5 = hello(5)

print(await (n3 + n4 + n5))
</code></pre>
<h3 id="循环并行"><a class="header" href="#循环并行">循环并行</a></h3>
<pre><code class="language-swift">await withTaskGroup(of: Int.self) { group in
    for i in 0..&lt;10 {
        group.async {
            let n = await hello(i)
            return n
        }
    }

}
</code></pre>
<h3 id="异步序列"><a class="header" href="#异步序列">异步序列</a></h3>
<pre><code class="language-swift">var sum = 0
    
for await result in group {
    sum += result
}

print(sum)
</code></pre>
<h2 id="群组"><a class="header" href="#群组">群组</a></h2>
<pre><code class="language-swift">// 保证群组内的相对顺序，不保证群组间的顺序
async let g0: Int = {
    let n0 = await hello(0)
    let n1 = await hello(1)
    let n2 = await hello(2)
    return n0 + n1 + n2
}()

async let g1: Int = {
    let n3 = await hello(3)
    let n4 = await hello(4)
    let n5 = await hello(5)
    return n3 + n4 + n5
}()

async let g2: Int = {
    let n6 = await hello(6)
    let n7 = await hello(7)
    let n8 = await hello(8)
    return n6 + n7 + n8
}()

print(await (g0 + g1 + g2))
</code></pre>
<h2 id="数据竞争-1"><a class="header" href="#数据竞争-1">数据竞争</a></h2>
<h3 id="数据未隔离"><a class="header" href="#数据未隔离">数据未隔离</a></h3>
<pre><code class="language-swift">var data = 0

await withTaskGroup(of: Void.self) { group in
    for _ in 0..&lt;10000 {
        group.async {
            data += 1
        }
    }
}

print(data)
</code></pre>
<h3 id="参与者"><a class="header" href="#参与者">参与者</a></h3>
<pre><code class="language-swift">// 参与者也是引用类型
actor SafeData {
    private(set) var data = 0
    
    func add(_ number: Int) {
        // 将可能引起数据竞争的逻辑放到参与者中
        
        self.data += number
    }
}

let safeData = SafeData()

await withTaskGroup(of: Void.self) { group in
    for _ in 0..&lt;10000 {
        group.async {
            await safeData.add(1)
        }
    }
}

print(await safeData.data)
</code></pre>
<h2 id="结构化任务"><a class="header" href="#结构化任务">结构化任务</a></h2>
<h3 id="串行-1"><a class="header" href="#串行-1">串行</a></h3>
<pre><code class="language-swift">await withTaskGroup(of: Int.self) { group0 in
        
    group0.async {
        let n0 = await hello(0)
        await withTaskGroup(of: Int.self) { group1 in
            
            group1.async {
                let n1 = await hello(1)
                await withTaskGroup(of: Int.self) { group2 in
                    
                    group2.async {
                        let n2 = await hello(2)
                        return n2
                    }
                }
                return n1
            }
        }
        return n0
    }
}
</code></pre>
<h3 id="并行-1"><a class="header" href="#并行-1">并行</a></h3>
<pre><code class="language-swift">await withTaskGroup(of: Int.self) { group in
    group.async {
        let n = await hello(3)
        return n
    }
    group.async {
        let n = await hello(4)
        return n
    }
    group.async {
        let n = await hello(5)
        return n
    }
    
    print(await (group.next()! + group.next()! + group.next()!))
}
</code></pre>
<h3 id="群组-1"><a class="header" href="#群组-1">群组</a></h3>
<pre><code class="language-swift">await withTaskGroup(of: Int.self) { group in
    group.async {
        let n0 = await hello(0)
        let n1 = await hello(1)
        let n2 = await hello(2)
        return n0 + n1 + n2
    }
    group.async {
        let n3 = await hello(3)
        let n4 = await hello(4)
        let n5 = await hello(5)
        return n3 + n4 + n5
    }
    group.async {
        let n6 = await hello(6)
        let n7 = await hello(7)
        let n8 = await hello(8)
        return n6 + n7 + n8
    }
    
    print(await (group.next()! + group.next()! + group.next()!))
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="alamofire"><a class="header" href="#alamofire">Alamofire</a></h1>
<h2 id="请求"><a class="header" href="#请求">请求</a></h2>
<h3 id="get"><a class="header" href="#get">GET</a></h3>
<pre><code class="language-swift">// 默认method: .get
AF.request(&quot;https://httpbin.org/get&quot;).response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="post"><a class="header" href="#post">POST</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/post&quot;, method: .post).response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="put"><a class="header" href="#put">PUT</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/put&quot;, method: .put).response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="delete"><a class="header" href="#delete">DELETE</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/delete&quot;, method: .delete).response { response in
    debugPrint(response)
}
</code></pre>
<h2 id="带参数请求"><a class="header" href="#带参数请求">带参数请求</a></h2>
<h3 id="get-url编码"><a class="header" href="#get-url编码">GET-URL编码</a></h3>
<ul>
<li>
<h4 id="模型"><a class="header" href="#模型">模型</a></h4>
</li>
</ul>
<pre><code class="language-swift">struct Query: Encodable {
    let year: Int
    let month: Int
    let day: Int
}

let query = Query(year: 2021, month: 7, day: 29)
// 默认encoder: URLEncodedFormParameterEncoder.default
AF.request(&quot;https://httpbin.org/get&quot;, parameters: query).response { response in
    debugPrint(response)
}
</code></pre>
<ul>
<li>
<h4 id="字典"><a class="header" href="#字典">字典</a></h4>
</li>
</ul>
<pre><code class="language-swift">let query = [
    &quot;year&quot;: 2021,
    &quot;month&quot;: 7,
    &quot;day&quot;: 29
]

AF.request(&quot;https://httpbin.org/get&quot;, parameters: query).response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="post-json编码"><a class="header" href="#post-json编码">POST-JSON编码</a></h3>
<ul>
<li>
<h4 id="模型-1"><a class="header" href="#模型-1">模型</a></h4>
</li>
</ul>
<pre><code class="language-swift">struct User: Encodable {
    let name: String
    let password: String
}

let user = User(name: &quot;hello&quot;, password: &quot;world&quot;)

AF.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: user, encoder: JSONParameterEncoder.default).response { response in
    debugPrint(response)
}
</code></pre>
<ul>
<li>
<h4 id="字典-1"><a class="header" href="#字典-1">字典</a></h4>
</li>
</ul>
<pre><code class="language-swift">let user = [
    &quot;name&quot;: &quot;hello&quot;,
    &quot;password&quot;: &quot;world&quot;
]

AF.request(&quot;https://httpbin.org/post&quot;, method: .post, parameters: user, encoder: JSONParameterEncoder.default).response { response in
    debugPrint(response)
}
</code></pre>
<h2 id="响应"><a class="header" href="#响应">响应</a></h2>
<h3 id="json"><a class="header" href="#json">JSON</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/json&quot;).responseJSON { response in
    debugPrint(response)
}
</code></pre>
<h3 id="data"><a class="header" href="#data">Data</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/json&quot;).responseData { response in
    debugPrint(response)
}
</code></pre>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/json&quot;).responseString { response in
    debugPrint(response)
}
</code></pre>
<h3 id="模型解析"><a class="header" href="#模型解析">模型解析</a></h3>
<pre><code class="language-swift">struct HTTPBinResponse: Decodable {
    let args: [String: String]
    let headers: [String: String]
    let origin: String
    let url: String
}

AF.request(&quot;https://httpbin.org/get&quot;).responseDecodable(of: HTTPBinResponse.self) { response in
    debugPrint(response)
}
</code></pre>
<h2 id="下载"><a class="header" href="#下载">下载</a></h2>
<h3 id="基本"><a class="header" href="#基本">基本</a></h3>
<pre><code class="language-swift">AF.download(&quot;https://httpbin.org/image/png&quot;).response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="下载地址"><a class="header" href="#下载地址">下载地址</a></h3>
<pre><code class="language-swift">let destination = DownloadRequest.suggestedDownloadDestination(for: .desktopDirectory, in: .userDomainMask)

AF.download(&quot;https://httpbin.org/image/png&quot;, to: destination).response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="下载进度"><a class="header" href="#下载进度">下载进度</a></h3>
<pre><code class="language-swift">AF.download(&quot;https://swift.org/builds/swift-5.5-branch/xcode/swift-5.5-DEVELOPMENT-SNAPSHOT-2021-07-27-a/swift-5.5-DEVELOPMENT-SNAPSHOT-2021-07-27-a-osx.pkg&quot;).downloadProgress { progress in
    print(progress.fractionCompleted)
}.response { response in
    debugPrint(response)
}
</code></pre>
<h2 id="不常用"><a class="header" href="#不常用">不常用</a></h2>
<h3 id="设置其它请求参数"><a class="header" href="#设置其它请求参数">设置其它请求参数</a></h3>
<pre><code class="language-swift">AF.request(&quot;https://httpbin.org/get&quot;) { request in
    request.timeoutInterval = 0.1
}.response { response in
    debugPrint(response)
}
</code></pre>
<h3 id="请求头"><a class="header" href="#请求头">请求头</a></h3>
<pre><code class="language-swift">let headers: HTTPHeaders = [
    .accept(&quot;application/json&quot;)
]

AF.request(&quot;https://httpbin.org/headers&quot;, headers: headers).response { response in
    debugPrint(response)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="objective-c组件库用swift转写的方法论"><a class="header" href="#objective-c组件库用swift转写的方法论">Objective-C组件库用Swift转写的方法论</a></h1>
<h2 id="oc库重构拆分"><a class="header" href="#oc库重构拆分">OC库重构拆分</a></h2>
<p>目的为将组件库拆分为OC特性和可用Swift替换的两部分</p>
<p>进入组件Pod目录，复制Classes文件夹下所有文件并重命名为Classes_Swift，新建空的Classes_OC文件夹。
全局搜索#define、typedef、static，将所有搜索到的头文件拆分（.m文件可以忽略），将#define宏拆分出来在原文件名基础上加上后缀_Macro，将typedef拆分出来再原文件名基础上加上后缀_TypeDef，将static拆分出来在原文件名基础上加上后缀_Global。
整个文件本身全部都是#define宏、typedef、static静态变量的，直接将文件移动至Classes_OC文件夹。新建三个目录，Macro、TypeDef、Global，将拆分出来的文件分类放入。</p>
<p>此外还有Swift无法表示的NSInvocation，Swift类无法被OC继承ObjcSubclassingRestricted</p>
<p>最后修改podspec<code>s.source_files = 'Pod/Classes_Swift/**/*.{h,m}', 'Pod/Classes_OC/**/*'</code></p>
<h2 id="使用swift转写替换"><a class="header" href="#使用swift转写替换">使用Swift转写替换</a></h2>
<p>文件命名和类命名和函数命名要与原组件库完全一致，此部分作为接口兼容外部业务的调用，可起名叫做OCDerecated。向外再抽一层，作为Swift风格的实现。</p>
<pre><code class="language-swift">@objcMembers
public class &lt;#NSClass#&gt;: NSObject {
    public static func &lt;#function#&gt;() {
        
    }
}
</code></pre>
<pre><code class="language-swift">@objc public extension &lt;#NSObject#&gt; {
    
}
</code></pre>
<pre><code class="language-swift">@objc public enum &lt;#NSEnum#&gt;: Int {
    case &lt;#one#&gt;
}
</code></pre>
<p>最后修改podspec<code>s.source_files = 'Pod/Classes_Swift/**/*.{swift}', 'Pod/Classes_OC/**/*'</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用扩展不可用编译错误"><a class="header" href="#应用扩展不可用编译错误">应用扩展不可用编译错误</a></h1>
<h2 id="问题描述"><a class="header" href="#问题描述">问题描述</a></h2>
<p>在带有应用扩展的工程中，组件库内使用<code>UIApplication.shared</code>，编译器报<code>'shared' is unavailable in application extensions for iOS: Use view controller based solutions where appropriate instead.</code>的错误</p>
<p>根据<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionOverview.html#//apple_ref/doc/uid/TP40014214-CH2-SW6">App Extension Programming Guide
</a>，<code>UIApplication.shared</code>以及其它使用<code>NS_EXTENSION_UNAVAILABLE</code>标记的API在应用扩展中不可用</p>
<h2 id="解决办法"><a class="header" href="#解决办法">解决办法</a></h2>
<p>为函数添加应用扩展不可用标记</p>
<p>函数默认是可以在应用扩展中调用的，这样在函数内部调用应用扩展不可用的API就会有问题。将函数标记为应用扩展不可用，可以类比将异常抛出，在用到应用扩展不可用的API的函数调用链的每一层全部加上应用扩展不可用标记，只要在应用扩展中不调用这些被标记的函数即可。换言之，被标记的函数在应用扩展中不可再被调用。</p>
<h3 id="swift-1"><a class="header" href="#swift-1">Swift</a></h3>
<pre><code class="language-swift">@available(iOSApplicationExtension, unavailable)
func methodUsedApplicationExtensionUnavailableAPI() {
    UIApplication.shared
}
</code></pre>
<h3 id="oc"><a class="header" href="#oc">OC</a></h3>
<pre><code class="language-objc">- (void)methodUsedApplicationExtensionUnavailableAPI NS_EXTENSION_UNAVAILABLE_IOS(&quot;&quot;) {
    [UIApplication sharedApplication];
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift-指针"><a class="header" href="#swift-指针">Swift 指针</a></h1>
<h2 id="unsafepointer--const-"><a class="header" href="#unsafepointer--const-">UnsafePointer | const *</a></h2>
<pre><code class="language-swift">let a = 3
withUnsafePointer(to: a) { p in
    print(p.pointee)
}
</code></pre>
<pre><code class="language-c">const int a = 3;
const int *p = &amp;a;
printf(&quot;%d\n&quot;, *p);
</code></pre>
<h2 id="unsafemutablepointer--"><a class="header" href="#unsafemutablepointer--">UnsafeMutablePointer | *</a></h2>
<pre><code class="language-swift">var a = 0
withUnsafeMutablePointer(to: &amp;a) { p in
    p.pointee += 1
}
print(a)
</code></pre>
<pre><code class="language-c">int a = 0;
int *p = &amp;a;
*p += 1;
printf(&quot;%d\n&quot;, a);
</code></pre>
<h2 id="unsafebufferpointer--const--"><a class="header" href="#unsafebufferpointer--const--">UnsafeBufferPointer | const * []</a></h2>
<pre><code class="language-swift">let a = [0, 1, 2]
a.withUnsafeBufferPointer { p in
    for i in 0..&lt;3 {
        print(p[i])
    }
}
</code></pre>
<pre><code class="language-c">const int a[] = {0, 1, 2};
const int *p = a;

for(int i = 0; i &lt; 3; i++) {
    printf(&quot;%d\n&quot;, *p);
    p += 1;
}
</code></pre>
<h2 id="unsafemutablebufferpointer---"><a class="header" href="#unsafemutablebufferpointer---">UnsafeMutableBufferPointer | * []</a></h2>
<pre><code class="language-swift">var a = [0, 1, 2]
a.withUnsafeMutableBufferPointer { p in
    for i in 0..&lt;3 {
        p[i] = p[i] + 3
    }
}

print(a)
</code></pre>
<pre><code class="language-c">int a[] = {0, 1, 2};
int *p = a;

for(int i = 0; i &lt; 3; i++) {
    *p = *p + 3;
    p += 1;
}

p = a;

for(int i = 0; i &lt; 3; i++) {
    printf(&quot;%d\n&quot;, *p);
    p += 1;
}
</code></pre>
<h2 id="unsaferawpointer--const-void-"><a class="header" href="#unsaferawpointer--const-void-">UnsafeRawPointer | const void *</a></h2>
<pre><code class="language-swift">let a = 3
let c = &quot;c&quot;

var p = withUnsafePointer(to: a, UnsafeRawPointer.init)

print(p.assumingMemoryBound(to: Int.self).pointee)

p.withMemoryRebound(to: Int.self, capacity: 1) { p in
    print(p.pointee)
}

p = withUnsafePointer(to: c, UnsafeRawPointer.init)

print(p.assumingMemoryBound(to: String.self).pointee)

p.withMemoryRebound(to: String.self, capacity: 1) { p in
    print(p.pointee)
}
</code></pre>
<pre><code class="language-c">const int a = 3;
const char c = 'c';
const void *p = &amp;a;
printf(&quot;%d\n&quot;, *(int*)p);
p = &amp;c;
printf(&quot;%c\n&quot;, *(char*)p);
</code></pre>
<h2 id="unsafemutablerawpointer--void-"><a class="header" href="#unsafemutablerawpointer--void-">UnsafeMutableRawPointer | void *</a></h2>
<pre><code class="language-swift">var a = 0
var c = &quot;0&quot;

var p = withUnsafeMutablePointer(to: &amp;a, UnsafeMutableRawPointer.init)

p.assumingMemoryBound(to: Int.self).pointee += 1

print(a)

p = withUnsafeMutablePointer(to: &amp;c, UnsafeMutableRawPointer.init)

p.assumingMemoryBound(to: String.self).pointee = &quot;1&quot;

print(c)
</code></pre>
<pre><code class="language-c">int a = 0;
char c = '0';
void *p = &amp;a;
*(int*)p += 1;
printf(&quot;%d\n&quot;, a);
p = &amp;c;
*(char*)p = '1';
printf(&quot;%c\n&quot;, c);
</code></pre>
<h2 id="unsaferawbufferpointer--char-"><a class="header" href="#unsaferawbufferpointer--char-">UnsafeRawBufferPointer | char *</a></h2>
<pre><code class="language-swift">let a = 0x01020304
withUnsafeBytes(of: a) { p in
    for i in 0..&lt;p.count {
        print(String(p[i], radix: 16))
    }
}
</code></pre>
<pre><code class="language-c">const int a = 0x01020304;
const char *p = (char *)&amp;a;
for (int i = 0; i &lt; sizeof(int); i++) {
    printf(&quot;%x\n&quot;, p[i]);
}
</code></pre>
<h2 id="allocatecapacity-deallocate--malloc-free"><a class="header" href="#allocatecapacity-deallocate--malloc-free">allocate(capacity:) deallocate() | malloc() free()</a></h2>
<pre><code class="language-swift">let p = UnsafeMutablePointer&lt;Int&gt;.allocate(capacity: 1)
p.pointee = 3
print(p.pointee)
p.deallocate()
</code></pre>
<pre><code class="language-c">int *p = (int*)malloc(1);
*p = 3;
printf(&quot;%d\n&quot;, *p);
free(p);
</code></pre>
<h2 id="memorylayout--sizeof"><a class="header" href="#memorylayout--sizeof">MemoryLayout | sizeof()</a></h2>
<pre><code class="language-swift">MemoryLayout&lt;CChar&gt;.size
</code></pre>
<pre><code class="language-c">sizeof(char)
</code></pre>
<h3 id="内存对齐"><a class="header" href="#内存对齐">内存对齐</a></h3>
<pre><code class="language-swift">struct T {
    var a: Int32
    var b: CChar
    var c: CChar
}

print(MemoryLayout&lt;T&gt;.size) // 4 + 1 + 1
print(MemoryLayout&lt;T&gt;.alignment) // 4
print(MemoryLayout&lt;T&gt;.stride) // 4 + [(1 + 1) -&gt; 4]


struct T {
    var b: CChar
    var a: Int32
    var c: CChar
}

print(MemoryLayout&lt;T&gt;.size) // [1 -&gt; 4] + 4 + 1
print(MemoryLayout&lt;T&gt;.alignment) // 4
print(MemoryLayout&lt;T&gt;.stride) // [1 -&gt; 4] + 4 + [1 -&gt; 4]


struct T {
    var b: CChar
    var c: CChar
    var a: Int32
}

print(MemoryLayout&lt;T&gt;.size) // [(1 + 1) -&gt; 4] + 4
print(MemoryLayout&lt;T&gt;.alignment) // 4
print(MemoryLayout&lt;T&gt;.stride) // [(1 + 1) -&gt; 4] + 4
</code></pre>
<pre><code class="language-c">struct T {
    int a;
    char b;
    char c;
};

printf(&quot;%lu\n&quot;, sizeof(struct T)); // 8
</code></pre>
<h2 id="unmanaged"><a class="header" href="#unmanaged">Unmanaged</a></h2>
<pre><code class="language-swift">class SomeClass {
    
}

func printAddress&lt;T: AnyObject&gt;(_ object: T) {
//    print(String(unsafeBitCast(object, to: Int.self), radix: 16, uppercase: false))
    print(Unmanaged&lt;T&gt;.passUnretained(object).toOpaque())
}

printAddress(SomeClass()) // 打印对象内存地址
</code></pre>
<h2 id="函数指针"><a class="header" href="#函数指针">函数指针</a></h2>
<h3 id="普通闭包"><a class="header" href="#普通闭包">普通闭包</a></h3>
<pre><code class="language-swift">//void someMethod(void (*block)(int)) {
//    block(1);
//}

// 与C混编时C风格闭包会自动转换为Swift风格闭包
someMethod { x in
    print(x)
}
</code></pre>
<pre><code class="language-c">void someMethod(void (*block)(int)) {
    block(1);
}

void closure(int x) {
    printf(&quot;%d\n&quot;, x);
}

someMethod(closure);
</code></pre>
<h3 id="void-任意类型函数指针闭包"><a class="header" href="#void-任意类型函数指针闭包">void *任意类型函数指针闭包</a></h3>
<pre><code class="language-swift">//void someMethod(const void *block) {
//    printf(&quot;%p\n&quot;, block);
//}
//
//void closure(int x) {
//    printf(&quot;%d\n&quot;, x);
//}

let c_func: @convention(c) (Int32) -&gt; Void = closure
let c_func_ptr = unsafeBitCast(c_func, to: UnsafeRawPointer.self)
someMethod(c_func_ptr)
</code></pre>
<pre><code class="language-c">void someMethod(const void *block) {
    printf(&quot;%p\n&quot;, block);
}

void closure(int x) {
    printf(&quot;%d\n&quot;, x);
}

someMethod(closure);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="css"><a class="header" href="#css">CSS</a></h1>
<h2 id="1-csshtml都不区分大小写"><a class="header" href="#1-csshtml都不区分大小写">1. css,html都不区分大小写</a></h2>
<h2 id="2-imoprt-引入css"><a class="header" href="#2-imoprt-引入css">2. @imoprt 引入CSS</a></h2>
<h2 id="3-元素居中"><a class="header" href="#3-元素居中">3. 元素居中</a></h2>
<ul>
<li>
<h3 id="水平居中"><a class="header" href="#水平居中">水平居中</a></h3>
</li>
</ul>
<p>行内元素居中</p>
<pre><code class="language-css">.parent {
    text-align: center;
}
</code></pre>
<p>块级元素居中</p>
<pre><code class="language-css">.child {
    margin: auto
}
</code></pre>
<ul>
<li>
<h3 id="水平垂直居中"><a class="header" href="#水平垂直居中">水平垂直居中</a></h3>
</li>
</ul>
<pre><code class="language-css">.parent {
    position: relative;
}
.child {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}
</code></pre>
<pre><code class="language-css">.parent {
    position: relative;
}
.child {
    position:absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
}
</code></pre>
<pre><code class="language-css">.parent {
    display: flex;
    justify-content: center;
    align-items: center;
}
</code></pre>
<pre><code class="language-css">.parent {
    display: flex;
}
.child {
    margin: auto;
}
</code></pre>
<h2 id="4-marginpadding对block和inline元素的不同影响"><a class="header" href="#4-marginpadding对block和inline元素的不同影响">4. margin,padding对block和inline元素的不同影响</a></h2>
<ul>
<li>
<h3 id="总结来说横向内外边距对所有元素都起作用纵向内外边距只对块级元素和可替换行内元素起作用"><a class="header" href="#总结来说横向内外边距对所有元素都起作用纵向内外边距只对块级元素和可替换行内元素起作用">总结来说，横向内外边距对所有元素都起作用，纵向内外边距只对块级元素和可替换行内元素起作用</a></h3>
</li>
<li>
<h3 id="margin-top-margin-bottom对inline元素"><a class="header" href="#margin-top-margin-bottom对inline元素">margin-top, margin-bottom对inline元素</a></h3>
</li>
</ul>
<p>margin-left,margin-right对所有元素都起作用；
margin-top,margin-bottom只对块级(block)元素起作用，对大部分行内元素(inline)是不起作用的，
原因在于margin-top,margin-bottom影响不到inline元素的行高(line-height)，因此没有预期视觉效果；
不过对于可替换元素，margin-top,margin-bottom可以起作用</p>
<ul>
<li>
<h3 id="padding-toppadding-bottom对inline元素"><a class="header" href="#padding-toppadding-bottom对inline元素">padding-top,padding-bottom对inline元素</a></h3>
</li>
</ul>
<p>几乎和margin一样，只不过padding-top,padding-bottom对inline元素时，设置背景可以看到内边距增大，
可惜依然影响不到行高，不会撑开它的父级元素</p>
<h2 id="5-rem"><a class="header" href="#5-rem">5. rem</a></h2>
<p>rem是以html中font-size为基准的相对度量单位，在这里给t类型设置宽度为10rem=10 * 20px = 200px</p>
<pre><code class="language-css">html {
    font-size: 20px;
}
.t {
    width: 10rem;
}
</code></pre>
<h2 id="6-checked用于选择input-typeradioinput-typecheckboxoptioninselect选中的样式"><a class="header" href="#6-checked用于选择input-typeradioinput-typecheckboxoptioninselect选中的样式">6. :checked用于选择<code>&lt;input type=&quot;radio&quot;&gt;&lt;input type=&quot;checkbox&quot;&gt;&lt;option&gt;in&lt;select&gt;</code>选中的样式</a></h2>
<h2 id="7-root选择文档的根元素"><a class="header" href="#7-root选择文档的根元素">7. :root选择文档的根元素</a></h2>
<h2 id="8--相邻兄弟选择器"><a class="header" href="#8--相邻兄弟选择器">8. + 相邻兄弟选择器</a></h2>
<h2 id="9-after在标签后插入"><a class="header" href="#9-after在标签后插入">9. :after在标签后插入</a></h2>
<h2 id="10-transform-translatexy-scalexy"><a class="header" href="#10-transform-translatexy-scalexy">10. transform: translate(x,y) scale(x,y)</a></h2>
<h2 id="11-only-排除不支持媒体查询的浏览器"><a class="header" href="#11-only-排除不支持媒体查询的浏览器">11. only 排除不支持媒体查询的浏览器</a></h2>
<h2 id="12-媒体查询实现自适应布局"><a class="header" href="#12-媒体查询实现自适应布局">12. 媒体查询实现自适应布局</a></h2>
<p>screen指的是浏览器窗口的大小，而不是物理设备屏幕的大小</p>
<pre><code class="language-css">@media screen and (min-width: 1000px) and (max-width: 2100px) {

}
</code></pre>
<h2 id="13-display-none会使元素彻底消失不显示visibility-hidden只是隐藏不显示但所占据的区域并不会释放"><a class="header" href="#13-display-none会使元素彻底消失不显示visibility-hidden只是隐藏不显示但所占据的区域并不会释放">13. display: none;会使元素彻底消失不显示，visibility: hidden;只是隐藏不显示，但所占据的区域并不会释放</a></h2>
<h2 id="14-重置resetcss就是把一些具有默认样式的元素清除自带样式可以消除不同浏览器带来的渲染差异"><a class="header" href="#14-重置resetcss就是把一些具有默认样式的元素清除自带样式可以消除不同浏览器带来的渲染差异">14. 重置(reset)CSS，就是把一些具有默认样式的元素清除自带样式，可以消除不同浏览器带来的渲染差异</a></h2>
<h2 id="15-css-sprites精灵图把小图片整合到一张图里可以减少http请求次数再使用backgroud-image和background-position来定位图片"><a class="header" href="#15-css-sprites精灵图把小图片整合到一张图里可以减少http请求次数再使用backgroud-image和background-position来定位图片">15. CSS sprites精灵图，把小图片整合到一张图里，可以减少http请求次数，再使用backgroud-image和background-position来定位图片</a></h2>
<h2 id="16-为获得统一的页面效果给不同浏览器不同的版本写不同样式就叫做css-hack"><a class="header" href="#16-为获得统一的页面效果给不同浏览器不同的版本写不同样式就叫做css-hack">16. 为获得统一的页面效果，给不同浏览器不同的版本写不同样式就叫做CSS hack</a></h2>
<h2 id="17-高效css选择组合选择器是从右到左解析的效率-id--class--tag"><a class="header" href="#17-高效css选择组合选择器是从右到左解析的效率-id--class--tag">17. 高效CSS选择，组合选择器是从右到左解析的，效率: #id &gt; .class &gt; tag</a></h2>
<h2 id="18-选择器优先级-id--class--tag"><a class="header" href="#18-选择器优先级-id--class--tag">18. 选择器优先级: #id &gt; .class &gt; tag</a></h2>
<h2 id="19-float浮动"><a class="header" href="#19-float浮动">19. float浮动</a></h2>
<p>向左或向右浮动，直到边缘触碰到父元素的边框或者触碰到另一个浮动元素的边框</p>
<h2 id="20-行内元素设置width和height无效"><a class="header" href="#20-行内元素设置width和height无效">20. 行内元素设置width和height无效</a></h2>
<h2 id="21-块级格式上下文-bfc"><a class="header" href="#21-块级格式上下文-bfc">21. 块级格式上下文 BFC</a></h2>
<p>BFC的目的是为了形成一个完全独立的容器，让其中的子元素不会影响到外面的布局</p>
<ul>
<li>
<h3 id="触发bfc的条件"><a class="header" href="#触发bfc的条件">触发BFC的条件</a></h3>
<ol>
<li>float不为none</li>
<li>position: absolute/fixed</li>
<li>display: inline-box</li>
<li>overflow: hidden/auto/scroll</li>
</ol>
</li>
<li>
<h3 id="bfc能解决的问题"><a class="header" href="#bfc能解决的问题">BFC能解决的问题</a></h3>
</li>
</ul>
<p>外边距垂直方向重合</p>
<pre><code class="language-html">&lt;div style=&quot;overflow: hidden;&quot;&gt;
    &lt;div style=&quot;width: 100px;height: 100px;background: lightblue;margin: 100px;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div style=&quot;overflow: hidden;&quot;&gt;
    &lt;div style=&quot;width: 100px;height: 100px;background: lightblue;margin: 100px;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>浮动元素的父元素高度塌陷</p>
<pre><code class="language-html">&lt;div style=&quot;border: 1px solid #000; overflow: hidden&quot;&gt;
    &lt;div style=&quot;width: 100px;height: 100px;background: #eee;float: left;&quot;&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>浮动元素覆盖</p>
<pre><code class="language-html">&lt;div style=&quot;height: 100px;width: 100px;float: left;background: lightblue&quot;&gt;&lt;/div&gt;
&lt;div style=&quot;width: 200px; height: 200px;background: #eee;overflow: hidden;&quot;&gt;&lt;/div&gt;
</code></pre>
<h2 id="22-css冲突问题"><a class="header" href="#22-css冲突问题">22. CSS冲突问题</a></h2>
<p>CSS文件分离不等于CSS作用域分离，只要最终CSS被引入统一文件就会发生CSS污染</p>
<ul>
<li>
<h3 id="使用css预处理器用命名空间来隔离"><a class="header" href="#使用css预处理器用命名空间来隔离">使用CSS预处理器，用命名空间来隔离</a></h3>
</li>
</ul>
<pre><code class="language-css">.componentA {
    .title {
        width: 100px;
    }
}
.componentB {
    .title {
        width: 200px;
    }
}
</code></pre>
<pre><code class="language-html">&lt;div class='componentA'&gt;
    &lt;div class='title'&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class='componentB'&gt;
    &lt;div class='title'&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
<ul>
<li>
<h3 id="使用css-in-js"><a class="header" href="#使用css-in-js">使用CSS in JS</a></h3>
</li>
<li>
<h3 id="配置webpack使css作用域为局部module"><a class="header" href="#配置webpack使css作用域为局部module">配置Webpack使CSS作用域为局部module</a></h3>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="html"><a class="header" href="#html">HTML</a></h1>
<h2 id="1-bdo-dirrtl可以改变文本的左右书写顺序rtl即right-to-left"><a class="header" href="#1-bdo-dirrtl可以改变文本的左右书写顺序rtl即right-to-left">1. <code>&lt;bdo dir=&quot;rtl&quot;&gt;</code>可以改变文本的左右书写顺序，rtl即right to left</a></h2>
<h2 id="2-small使用场景一般是版权信息和法律文本"><a class="header" href="#2-small使用场景一般是版权信息和法律文本">2. <code>&lt;small&gt;</code>使用场景一般是版权信息和法律文本</a></h2>
<h2 id="3-mark使文本高亮"><a class="header" href="#3-mark使文本高亮">3. <code>&lt;mark&gt;</code>使文本高亮</a></h2>
<h2 id="4-a本身是行内元素但是子元素为块级元素时也支持块级链接"><a class="header" href="#4-a本身是行内元素但是子元素为块级元素时也支持块级链接">4. <code>&lt;a&gt;</code>本身是行内元素，但是子元素为块级元素时也支持块级链接</a></h2>
<h2 id="5-doctype-html作用是对文档进行有效性验证决定浏览器的呈现模式"><a class="header" href="#5-doctype-html作用是对文档进行有效性验证决定浏览器的呈现模式">5. <code>&lt;!DOCTYPE html&gt;</code>作用是：对文档进行有效性验证，决定浏览器的呈现模式</a></h2>
<h2 id="6-div-data-test-numberdiv用于数据传输自定义数据可以从datasettestnumber获取"><a class="header" href="#6-div-data-test-numberdiv用于数据传输自定义数据可以从datasettestnumber获取">6. <code>&lt;div data-test-number&gt;&lt;/div&gt;</code>用于数据传输，自定义数据可以从<code>dataset.testNumber</code>获取</a></h2>
<h2 id="7-localstorage永久存储sessionstorage会话内有效cookies会随请求发送到服务器"><a class="header" href="#7-localstorage永久存储sessionstorage会话内有效cookies会随请求发送到服务器">7. LocalStorage永久存储，SessionStorage会话内有效，cookies会随请求发送到服务器</a></h2>
<h2 id="8-get-和-post的区别"><a class="header" href="#8-get-和-post的区别">8. GET 和 POST的区别</a></h2>
<ul>
<li>GET明文传输数据，数据以?和&amp;拼接并附加在请求资源地址之后</li>
<li>POST传输的数据封装在http报文的请求体(body)中</li>
</ul>
<h2 id="9-block-inline"><a class="header" href="#9-block-inline">9. block, inline</a></h2>
<ul>
<li>
<h3 id="block"><a class="header" href="#block">block</a></h3>
</li>
</ul>
<p><code>&lt;p&gt;, &lt;div&gt;, &lt;h1&gt;, &lt;ol&gt;, &lt;ul&gt;, &lt;dl&gt;, &lt;table&gt;, &lt;address&gt;, &lt;blockquote&gt;, &lt;form&gt;</code></p>
<ul>
<li>
<h3 id="inline"><a class="header" href="#inline">inline</a></h3>
</li>
</ul>
<p><code>&lt;a&gt;, &lt;span&gt;, &lt;br&gt;, &lt;i&gt;, &lt;em&gt;, &lt;strong&gt;, &lt;lable&gt;, &lt;q&gt;, &lt;var&gt;, &lt;cite&gt;, &lt;code&gt;</code></p>
<ul>
<li>
<h3 id="inline-block"><a class="header" href="#inline-block">inline-block</a></h3>
</li>
</ul>
<p><code>&lt;img&gt;, &lt;input&gt;</code></p>
<h2 id="10-可替换元素replaced-element"><a class="header" href="#10-可替换元素replaced-element">10. 可替换元素(replaced element)</a></h2>
<p>展现效果不由CSS控制，渲染独立于CSS的元素，可理解为标签只为占位，渲染由其它替换；
有<code>&lt;iframe&gt;, &lt;video&gt;, &lt;embed&gt;, &lt;img&gt;, &lt;input&gt;</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript"><a class="header" href="#javascript">JavaScript</a></h1>
<h2 id="1-事件代理"><a class="header" href="#1-事件代理">1. 事件代理</a></h2>
<p>借助点击时事件(event)会附带被点击的元素的DOM子树(target)；当给很多元素添加事件的时候，可以给这些元素的
共同父元素添加事件，借助target和事件冒泡传递，使父元素代理子元素的事件处理</p>
<h2 id="2-prototype"><a class="header" href="#2-prototype">2. prototype</a></h2>
<pre><code class="language-javascript">class C {
    a = 1
}

C.prototype.getA = function (x) {
    return this.a + x
}

new C().getA(2)
</code></pre>
<h2 id="3-闭包"><a class="header" href="#3-闭包">3. 闭包</a></h2>
<p>函数和函数内部能访问到的变量的总和，就是一个闭包</p>
<p>function foo是为了证明变量a是局部变量，能达到闭包的目的隐藏变量；
return function bar的目的是为了bar函数能被使用，这两者都与闭包本身无关</p>
<p>闭包的作用是隐藏变量，能让函数外部访问内部隐藏的局部变量，且能保护局部变量不被外部干扰</p>
<pre><code class="language-javascript">function foo() {
    var a = 1
    return function bar() {
        a += 1
        return a
    }
}

console.log(foo()()) // 2
console.log(a) // a is not defined
</code></pre>
<pre><code class="language-javascript">function f(callback) {
    var a = 1
    callback(a)
}

f(a =&gt; {
    console.log(a)
})
</code></pre>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
    (function (e) {
        setTimeout(function () {
            console.log(e)
        }, 1000)
    })(i)
}
</code></pre>
<h2 id="4-undeclared是语法错误表示没有声明undefined表示根本未被定义null是被定义了但是被定义的是空值"><a class="header" href="#4-undeclared是语法错误表示没有声明undefined表示根本未被定义null是被定义了但是被定义的是空值">4. undeclared是语法错误表示没有声明，undefined表示根本未被定义，null是被定义了但是被定义的是空值</a></h2>
<h2 id="5--相等运算符--严格相等运算符"><a class="header" href="#5--相等运算符--严格相等运算符">5. == 相等运算符， === 严格相等运算符</a></h2>
<h2 id="6-use-strict严格模式下不允许使用未声明的变量"><a class="header" href="#6-use-strict严格模式下不允许使用未声明的变量">6. &quot;use strict&quot;严格模式下，不允许使用未声明的变量</a></h2>
<h2 id="7-编译阶段函数声明和变量声明会被提前到环境顶部函数声明的优先级又高于变量声明据此来分析js代码"><a class="header" href="#7-编译阶段函数声明和变量声明会被提前到环境顶部函数声明的优先级又高于变量声明据此来分析js代码">7. 编译阶段，函数声明和变量声明会被提前到环境顶部，函数声明的优先级又高于变量声明；据此来分析js代码</a></h2>
<h2 id="8-模块模式减少命名冲突"><a class="header" href="#8-模块模式减少命名冲突">8. 模块模式，减少命名冲突</a></h2>
<pre><code class="language-javascript">var m = (function () {
    function a() {
        console.log('a')
    }

    function b() {
        console.log('b')
    }

    return {
        a,
        b
    }
})()

m.a()
</code></pre>
<h2 id="9-call-和-apply-的用法"><a class="header" href="#9-call-和-apply-的用法">9. call 和 apply 的用法</a></h2>
<pre><code class="language-javascript">function f1(x, y, z) {
    console.log(x, y, z)
}

function f2(x, y, z) {
    console.log(x, y, z)
    f1.apply(this, arguments)
}
f2.call(this, 1, 2, 3)
</code></pre>
<h2 id="10-async-await-和-promise"><a class="header" href="#10-async-await-和-promise">10. async, await 和 Promise</a></h2>
<pre><code class="language-javascript">function callback({ data, success, fail }) {
    setTimeout(() =&gt; {
        if (data.flag) {
            success('success')
        } else {
            fail('error')
        }
    }, 1000)
}

async function asyncPromise(data) {
    return await new Promise((resolve, reject) =&gt; {
        callback({
            data: {
                flag: data.flag
            },
            success: res =&gt; {
                resolve(res)
            },
            fail: err =&gt; {
                reject(err)
            }
        })
    })
}

(async () =&gt; {
    let res = await asyncPromise({
        flag: true
    })
    console.log(res)
})()
</code></pre>
<h2 id="11-this在函数中指向全局对象在方法中指向该方法所属对象"><a class="header" href="#11-this在函数中指向全局对象在方法中指向该方法所属对象">11. this在函数中指向全局对象，在方法中指向该方法所属对象</a></h2>
<h2 id="12-todo"><a class="header" href="#12-todo">12. todo</a></h2>
<h2 id="13-原型链"><a class="header" href="#13-原型链">13. 原型链</a></h2>
<ul>
<li>
<h3 id="prototype-和-constructor"><a class="header" href="#prototype-和-constructor">prototype 和 constructor</a></h3>
</li>
</ul>
<p>js中没有类的概念，ES6中有class关键字模拟了类但并不是真的类</p>
<p>每个函数都有一个原型对象，函数的prototype指向它的原型对象，原型对象的constructor又指回函数本身；
Object,Function也都是函数</p>
<ul>
<li>
<h3 id="proto"><a class="header" href="#proto"><strong>proto</strong></a></h3>
</li>
</ul>
<p>每个对象(函数也是对象)都有一个__proto__，这个__proto__指向创建它的函数的原型对象；所有的原型对象的__proto__又都指向Object.prototype；
最终Obejct.prototype的__proto__又指向null
当用new关键字使用函数构造一个实例对象的时候，这个对象的__proto__指向创建它的函数的原型对象</p>
<pre><code class="language-javascript">function foo() {

}

console.log(foo.prototype.constructor === foo)
console.log(Object.prototype.constructor === Object)
console.log(Function.prototype.constructor === Function)

console.log(foo.__proto__ === Function.prototype)
console.log(Object.__proto__ === Function.prototype)
console.log(Function.__proto__ === Function.prototype)

console.log(foo.prototype.__proto__ === Object.prototype)
console.log(Function.prototype.__proto__ === Object.prototype)
console.log(Object.prototype.__proto__ === null)
</code></pre>
<p><img src="Web/../images/prototype.jpeg" alt="原型链图片" /></p>
<h2 id="14-javascript-继承实现"><a class="header" href="#14-javascript-继承实现">14. JavaScript 继承实现</a></h2>
<ul>
<li>
<h3 id="原型链表实现继承"><a class="header" href="#原型链表实现继承">原型链表实现继承</a></h3>
</li>
</ul>
<pre><code class="language-javascript">function Super() {
    this.a = 1
}

function Sub() {

}

Sub.prototype = new Super()

var sub = new Sub()
console.log(sub.a)
</code></pre>
<ul>
<li>
<h3 id="call-实现继承"><a class="header" href="#call-实现继承">call 实现继承</a></h3>
</li>
</ul>
<pre><code class="language-javascript">function Super() {
    this.a = 1
}

function Sub() {
    Super.call(this)
}

var sub = new Sub()
console.log(sub.a)
</code></pre>
<ul>
<li>
<h3 id="组合继承"><a class="header" href="#组合继承">组合继承</a></h3>
</li>
</ul>
<pre><code class="language-javascript">function Super(a) {
    this.a = a
}

function Sub(a) {
    Super.call(this, a)
}

Sub.prototype = new Super()

var sub = new Sub(1)
console.log(sub.a)
</code></pre>
<h2 id="15-let-var-和-const-的区别"><a class="header" href="#15-let-var-和-const-的区别">15. let, var 和 const 的区别</a></h2>
<ul>
<li>
<h3 id="let-const可以定义块级作用域这里的块级作用域不等于函数函数内部闭包都会形成新的作用域"><a class="header" href="#let-const可以定义块级作用域这里的块级作用域不等于函数函数内部闭包都会形成新的作用域">let, const可以定义块级作用域，这里的块级作用域不等于函数，函数内部闭包都会形成新的作用域</a></h3>
</li>
</ul>
<pre><code class="language-javascript">{
    var a = 1
    let b = 1
    const c = 1
}
console.log(a) // 1
console.log(b) // error: b is not defined
console.log(c) // error: c is not defined
</code></pre>
<ul>
<li>
<h3 id="let-const不存在变量提升"><a class="header" href="#let-const不存在变量提升">let, const不存在变量提升</a></h3>
</li>
<li>
<h3 id="var-可以声明同名变量"><a class="header" href="#var-可以声明同名变量">var 可以声明同名变量</a></h3>
</li>
</ul>
<pre><code class="language-javascript">var a = 1
var a = 2
let b = 1
let b = 2
console.log(a)
console.log(b) // error
</code></pre>
<ul>
<li>
<h3 id="const-常量一旦声明不可再修改"><a class="header" href="#const-常量一旦声明不可再修改">const 常量一旦声明不可再修改</a></h3>
</li>
</ul>
<pre><code class="language-javascript">const c = 1
c = 2
console.log(c) // error: Assignment to constant variable.
</code></pre>
<p>但是可以修改复杂类型数据的属性</p>
<pre><code class="language-javascript">const obj = { a: 1 }
obj.a = 2
console.log(obj)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="javascript-1"><a class="header" href="#javascript-1">JavaScript</a></h1>
<h2 id="1-事件代理-1"><a class="header" href="#1-事件代理-1">1. 事件代理</a></h2>
<p>借助点击时事件(event)会附带被点击的元素的DOM子树(target)；当给很多元素添加事件的时候，可以给这些元素的
共同父元素添加事件，借助target和事件冒泡传递，使父元素代理子元素的事件处理</p>
<h2 id="2-prototype-1"><a class="header" href="#2-prototype-1">2. prototype</a></h2>
<pre><code class="language-javascript">class C {
    a = 1
}

C.prototype.getA = function (x) {
    return this.a + x
}

new C().getA(2)
</code></pre>
<h2 id="3-闭包-1"><a class="header" href="#3-闭包-1">3. 闭包</a></h2>
<p>函数和函数内部能访问到的变量的总和，就是一个闭包</p>
<p>function foo是为了证明变量a是局部变量，能达到闭包的目的隐藏变量；
return function bar的目的是为了bar函数能被使用，这两者都与闭包本身无关</p>
<p>闭包的作用是隐藏变量，能让函数外部访问内部隐藏的局部变量，且能保护局部变量不被外部干扰</p>
<pre><code class="language-javascript">function foo() {
    var a = 1
    return function bar() {
        a += 1
        return a
    }
}

console.log(foo()()) // 2
console.log(a) // a is not defined
</code></pre>
<pre><code class="language-javascript">function f(callback) {
    var a = 1
    callback(a)
}

f(a =&gt; {
    console.log(a)
})
</code></pre>
<pre><code class="language-javascript">for (var i = 0; i &lt; 10; i++) {
    (function (e) {
        setTimeout(function () {
            console.log(e)
        }, 1000)
    })(i)
}
</code></pre>
<h2 id="4-undeclared是语法错误表示没有声明undefined表示根本未被定义null是被定义了但是被定义的是空值-1"><a class="header" href="#4-undeclared是语法错误表示没有声明undefined表示根本未被定义null是被定义了但是被定义的是空值-1">4. undeclared是语法错误表示没有声明，undefined表示根本未被定义，null是被定义了但是被定义的是空值</a></h2>
<h2 id="5--相等运算符--严格相等运算符-1"><a class="header" href="#5--相等运算符--严格相等运算符-1">5. == 相等运算符， === 严格相等运算符</a></h2>
<h2 id="6-use-strict严格模式下不允许使用未声明的变量-1"><a class="header" href="#6-use-strict严格模式下不允许使用未声明的变量-1">6. &quot;use strict&quot;严格模式下，不允许使用未声明的变量</a></h2>
<h2 id="7-编译阶段函数声明和变量声明会被提前到环境顶部函数声明的优先级又高于变量声明据此来分析js代码-1"><a class="header" href="#7-编译阶段函数声明和变量声明会被提前到环境顶部函数声明的优先级又高于变量声明据此来分析js代码-1">7. 编译阶段，函数声明和变量声明会被提前到环境顶部，函数声明的优先级又高于变量声明；据此来分析js代码</a></h2>
<h2 id="8-模块模式减少命名冲突-1"><a class="header" href="#8-模块模式减少命名冲突-1">8. 模块模式，减少命名冲突</a></h2>
<pre><code class="language-javascript">var m = (function () {
    function a() {
        console.log('a')
    }

    function b() {
        console.log('b')
    }

    return {
        a,
        b
    }
})()

m.a()
</code></pre>
<h2 id="9-call-和-apply-的用法-1"><a class="header" href="#9-call-和-apply-的用法-1">9. call 和 apply 的用法</a></h2>
<pre><code class="language-javascript">function f1(x, y, z) {
    console.log(x, y, z)
}

function f2(x, y, z) {
    console.log(x, y, z)
    f1.apply(this, arguments)
}
f2.call(this, 1, 2, 3)
</code></pre>
<h2 id="10-async-await-和-promise-1"><a class="header" href="#10-async-await-和-promise-1">10. async, await 和 Promise</a></h2>
<pre><code class="language-javascript">function callback({ data, success, fail }) {
    setTimeout(() =&gt; {
        if (data.flag) {
            success('success')
        } else {
            fail('error')
        }
    }, 1000)
}

async function asyncPromise(data) {
    return await new Promise((resolve, reject) =&gt; {
        callback({
            data: {
                flag: data.flag
            },
            success: res =&gt; {
                resolve(res)
            },
            fail: err =&gt; {
                reject(err)
            }
        })
    })
}

(async () =&gt; {
    let res = await asyncPromise({
        flag: true
    })
    console.log(res)
})()
</code></pre>
<h2 id="11-this在函数中指向全局对象在方法中指向该方法所属对象-1"><a class="header" href="#11-this在函数中指向全局对象在方法中指向该方法所属对象-1">11. this在函数中指向全局对象，在方法中指向该方法所属对象</a></h2>
<h2 id="12-todo-1"><a class="header" href="#12-todo-1">12. todo</a></h2>
<h2 id="13-原型链-1"><a class="header" href="#13-原型链-1">13. 原型链</a></h2>
<ul>
<li>
<h3 id="prototype-和-constructor-1"><a class="header" href="#prototype-和-constructor-1">prototype 和 constructor</a></h3>
</li>
</ul>
<p>js中没有类的概念，ES6中有class关键字模拟了类但并不是真的类</p>
<p>每个函数都有一个原型对象，函数的prototype指向它的原型对象，原型对象的constructor又指回函数本身；
Object,Function也都是函数</p>
<ul>
<li>
<h3 id="proto-1"><a class="header" href="#proto-1"><strong>proto</strong></a></h3>
</li>
</ul>
<p>每个对象(函数也是对象)都有一个__proto__，这个__proto__指向创建它的函数的原型对象；所有的原型对象的__proto__又都指向Object.prototype；
最终Obejct.prototype的__proto__又指向null
当用new关键字使用函数构造一个实例对象的时候，这个对象的__proto__指向创建它的函数的原型对象</p>
<pre><code class="language-javascript">function foo() {

}

console.log(foo.prototype.constructor === foo)
console.log(Object.prototype.constructor === Object)
console.log(Function.prototype.constructor === Function)

console.log(foo.__proto__ === Function.prototype)
console.log(Object.__proto__ === Function.prototype)
console.log(Function.__proto__ === Function.prototype)

console.log(foo.prototype.__proto__ === Object.prototype)
console.log(Function.prototype.__proto__ === Object.prototype)
console.log(Object.prototype.__proto__ === null)
</code></pre>
<p><img src="Web/../images/prototype.jpeg" alt="原型链图片" /></p>
<h2 id="14-javascript-继承实现-1"><a class="header" href="#14-javascript-继承实现-1">14. JavaScript 继承实现</a></h2>
<ul>
<li>
<h3 id="原型链表实现继承-1"><a class="header" href="#原型链表实现继承-1">原型链表实现继承</a></h3>
</li>
</ul>
<pre><code class="language-javascript">function Super() {
    this.a = 1
}

function Sub() {

}

Sub.prototype = new Super()

var sub = new Sub()
console.log(sub.a)
</code></pre>
<ul>
<li>
<h3 id="call-实现继承-1"><a class="header" href="#call-实现继承-1">call 实现继承</a></h3>
</li>
</ul>
<pre><code class="language-javascript">function Super() {
    this.a = 1
}

function Sub() {
    Super.call(this)
}

var sub = new Sub()
console.log(sub.a)
</code></pre>
<ul>
<li>
<h3 id="组合继承-1"><a class="header" href="#组合继承-1">组合继承</a></h3>
</li>
</ul>
<pre><code class="language-javascript">function Super(a) {
    this.a = a
}

function Sub(a) {
    Super.call(this, a)
}

Sub.prototype = new Super()

var sub = new Sub(1)
console.log(sub.a)
</code></pre>
<h2 id="15-let-var-和-const-的区别-1"><a class="header" href="#15-let-var-和-const-的区别-1">15. let, var 和 const 的区别</a></h2>
<ul>
<li>
<h3 id="let-const可以定义块级作用域这里的块级作用域不等于函数函数内部闭包都会形成新的作用域-1"><a class="header" href="#let-const可以定义块级作用域这里的块级作用域不等于函数函数内部闭包都会形成新的作用域-1">let, const可以定义块级作用域，这里的块级作用域不等于函数，函数内部闭包都会形成新的作用域</a></h3>
</li>
</ul>
<pre><code class="language-javascript">{
    var a = 1
    let b = 1
    const c = 1
}
console.log(a) // 1
console.log(b) // error: b is not defined
console.log(c) // error: c is not defined
</code></pre>
<ul>
<li>
<h3 id="let-const不存在变量提升-1"><a class="header" href="#let-const不存在变量提升-1">let, const不存在变量提升</a></h3>
</li>
<li>
<h3 id="var-可以声明同名变量-1"><a class="header" href="#var-可以声明同名变量-1">var 可以声明同名变量</a></h3>
</li>
</ul>
<pre><code class="language-javascript">var a = 1
var a = 2
let b = 1
let b = 2
console.log(a)
console.log(b) // error
</code></pre>
<ul>
<li>
<h3 id="const-常量一旦声明不可再修改-1"><a class="header" href="#const-常量一旦声明不可再修改-1">const 常量一旦声明不可再修改</a></h3>
</li>
</ul>
<pre><code class="language-javascript">const c = 1
c = 2
console.log(c) // error: Assignment to constant variable.
</code></pre>
<p>但是可以修改复杂类型数据的属性</p>
<pre><code class="language-javascript">const obj = { a: 1 }
obj.a = 2
console.log(obj)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="taro快速开始"><a class="header" href="#taro快速开始">Taro快速开始</a></h1>
<h2 id="是什么"><a class="header" href="#是什么">是什么</a></h2>
<p>基于React的 <strong>类小程序解释器</strong>。<br />
使用Taro组件编写代码，使用脚手架工具解释成对应平台的小程序代码，进而调试、测试、发布。</p>
<h2 id="为什么"><a class="header" href="#为什么">为什么</a></h2>
<p>微信小程序糟糕且特立独行的~~架构设计~~使得代码的编写异常困难，编写的代码难以复用。使用React开发微信小程序可以提升代码复用率，<strong>组件化</strong>、<strong>模块化</strong>开发小程序可以极大地提升开发效率，使开发者尽情享受小程序的商业成果。</p>
<h2 id="怎么做-macos-20201127"><a class="header" href="#怎么做-macos-20201127">怎么做 (MacOS 2020.11.27)</a></h2>
<ul>
<li>
<h3 id="环境准备"><a class="header" href="#环境准备">环境准备</a></h3>
<p><a href="https://nodejs.org/en/">Node.js官网</a>下载安装包<br />
双击下载的安装包node-v14.15.1.pkg按照指引安装<br />
（实测最新15.3.0版本无法使用Taro）<br />
在终端输入<code>node</code>和<code>npm</code>检查Node.js环境</p>
</li>
<li>
<h3 id="仅使用taro"><a class="header" href="#仅使用taro">仅使用Taro</a></h3>
<ol>
<li>
<p>新建Taro项目（使用npx）<br />
<code>npx @tarojs/cli init [项目名]</code></p>
</li>
<li>
<p>切换到项目目录，安装Node包<br />
<code>cd [项目路径]</code><br />
<code>npm install</code></p>
</li>
<li>
<p>解释React代码为目标平台代码<br />
<code>npx taro build --type [目标平台]</code></p>
</li>
</ol>
<ul>
<li>
<p>注意事项：</p>
<ul>
<li>
<p>安装Node包时要找对路径，例如云开发路径为<code>./[项目名]/client</code><br />
不确定时可以执行<code>npm list</code>，如果提示有许多包没有安装那就对了</p>
</li>
<li>
<p>[type: 目标平台] = [weapp: 微信, alipay: 支付宝, tt: 头条, qq: 腾讯, jd: 京东, swan: 百度, h5: Web]</p>
</li>
<li>
<p>第3条后加<code>--watch</code>并打开微信开发者工具可以边调试代码边查看模拟器</p>
</li>
<li>
<p><code>src</code>是源代码路径，<code>dist</code>是生成的解释代码路径</p>
</li>
<li>
<p>可能需要关闭微信开发者工具的 ES6 转 ES5 功能，关闭上传代码时样式自动补全，关闭代码压缩上传，否则可能报错</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<h3 id="同时使用taro-ui"><a class="header" href="#同时使用taro-ui">同时使用Taro-UI</a></h3>
<ul>
<li>目前Taro和Taro-UI的适配不是很好，文档也没有及时更新，使用Taro3的模版代码竟然使用的是Taro-UI2，导致会自动下载Taro-UI2。然而UI2的架构已经无法适配，只能手动切换目前还处于开发阶段的Taro-UI3</li>
</ul>
<ol>
<li>
<p>新建Taro项目（使用npx）<br />
<code>npx @tarojs/cli init [项目名]</code></p>
</li>
<li>
<p>切换到项目目录，修改packgage.json依赖，安装Node包<br />
<code>cd [项目路径]</code><br />
<code>修改dependencies &quot;taro-ui&quot;: &quot;^3.0.0-alpha&quot;</code><br />
<code>npm install</code><br />
tips: 如果不幸按照仅使用Taro安装了，那就删掉所有的node_modules重新安装依赖</p>
</li>
<li>
<p>解释React代码为目标平台代码<br />
<code>npx taro build --type [目标平台]</code></p>
</li>
</ol>
</li>
<li>
<h3 id="代码编写"><a class="header" href="#代码编写">代码编写</a></h3>
<ul>
<li>
<p>Taro<br />
<code>import React, { Component } from 'react'</code><br />
<code>import { View } from '@tarojs/components'</code></p>
</li>
<li>
<p>Taro-UI<br />
<code>在app.js全局引入一次 import 'taro-ui/dist/style/index.scss'</code><br />
<code>import { AtButton } from 'taro-ui'</code></p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vue"><a class="header" href="#vue">Vue</a></h1>
<p>npx @vue/cli create todotasks-vue
cd todotasks-vue
npm run serve</p>
<p>npm i --save @fortawesome/fontawesome-svg-core
npm i --save @fortawesome/free-solid-svg-icons
npm i --save @fortawesome/vue-fontawesome@latest</p>
<p>import { library } from '@fortawesome/fontawesome-svg-core'
import { faUserSecret } from '@fortawesome/free-solid-svg-icons'
import { FontAwesomeIcon } from '@fortawesome/vue-fontawesome'</p>
<p>library.add(faUserSecret)</p>
<p>Vue.component('font-awesome-icon', FontAwesomeIcon)</p>
<ul>
<li></li>
</ul>
<p>npm i element-ui</p>
<p>import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css'
Vue.use(ElementUI)</p>
<p>v-bind == :
v-on == @
{{}}</p>
<h2 id="react"><a class="header" href="#react">React</a></h2>
<p>npx create-react-app todotasks-react
cd todotasks-react
npm start
npm run build</p>
<p>npm i --save @fortawesome/fontawesome-svg-core
npm i --save @fortawesome/free-solid-svg-icons
npm i --save @fortawesome/react-fontawesome</p>
<p>npm install antd --save</p>
<p>import { DatePicker } from 'antd'
import 'antd/dist/antd.css'</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http"><a class="header" href="#http">http</a></h1>
<h2 id="1-tcp三次握手和四次挥手"><a class="header" href="#1-tcp三次握手和四次挥手">1. TCP三次握手和四次挥手</a></h2>
<p>IP协议解决了主机IP之间的通信，TCP解决的是进程端口间的通信</p>
<ul>
<li>
<h3 id="三次握手"><a class="header" href="#三次握手">三次握手</a></h3>
</li>
</ul>
<ol>
<li>client  --&gt;  [SYN=1, seq = x]</li>
<li>[SYN=1, seq = y]; [ACK=1, seq = x + 1]  &lt;--  server</li>
<li>client  --&gt;  [ACK=1, seq = y + 1]</li>
</ol>
<p>报文有可能重复发送，client发送了两个不同的序列号，那么服务端如何确定和哪一个连接呢，返回序列号加一让客户端得知我就和你这个序列号连接了。
反过来服务端也是相同的道理。客户端服务端通过协商序列号来建立连接，以及按序列号组装数据</p>
<ul>
<li>
<h3 id="四次挥手"><a class="header" href="#四次挥手">四次挥手</a></h3>
</li>
</ul>
<ol>
<li>client  --&gt;  [FIN=1, seq = x]</li>
<li>[ACK=1, seq = x + 1]  &lt;--  server</li>
<li>[FIN=1, seq = y]      &lt;--  server</li>
<li>client  --&gt;  [ACK=1, seq = y + 1]</li>
</ol>
<p>在二三次挥手之间服务端仍然可以发送数据，客户端只是停止发送数据但是可以接收数据。在接到客户端结束连接请求后，服务端仍然有可能有未发送的响应数据，
等待数据发送完毕，再发送结束连接请求，客户端同意那么这个服务就可以停止了。</p>
<h2 id="2-从输入-url-到页面加载完成的过程中都发生了什么"><a class="header" href="#2-从输入-url-到页面加载完成的过程中都发生了什么">2. 从输入 URL 到页面加载完成的过程中都发生了什么</a></h2>
<ol>
<li>查找域名对应的IP地址，按浏览器DNS缓存、操作系统DNS缓存、区域DNS服务器的顺序查找</li>
<li>根据IP地址与服务器建立TCP/IP连接</li>
<li>根据URL生成http请求，得到http响应，依据HTML渲染显示网页</li>
</ol>
<h2 id="3-restful-api"><a class="header" href="#3-restful-api">3. RESTful API</a></h2>
<ol>
<li>用URL定位资源</li>
<li>GET/POST/PUT/DELETE来描述操作</li>
<li>传输数据json,xml,yaml</li>
<li>Status Code表示操作结果</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="性能优化"><a class="header" href="#性能优化">性能优化</a></h1>
<h2 id="1-减少http请求"><a class="header" href="#1-减少http请求">1. 减少http请求</a></h2>
<h2 id="2-使用http2"><a class="header" href="#2-使用http2">2. 使用http2</a></h2>
<h2 id="3-服务端渲染"><a class="header" href="#3-服务端渲染">3. 服务端渲染</a></h2>
<p>客户端渲染：获取html,执行js,渲染
服务端渲染：返回html,解析html,渲染</p>
<h2 id="4-静态资源cdn加速"><a class="header" href="#4-静态资源cdn加速">4. 静态资源CDN加速</a></h2>
<h2 id="5-css和javascript标签位置"><a class="header" href="#5-css和javascript标签位置">5. CSS和JavaScript标签位置</a></h2>
<p><code>&lt;head&gt;</code>标签里的CSS和JavaScript会阻塞渲染，但为了防止用户看到没有样式的丑陋的html骨架，CSS只能放到<code>&lt;head&gt;</code>里，
JavaScript则可以放到<code>&lt;body&gt;</code>标签的最底部</p>
<h2 id="6-使用字体图iconfont标代替图片图标"><a class="header" href="#6-使用字体图iconfont标代替图片图标">6. 使用字体图iconfont标代替图片图标</a></h2>
<h2 id="7-缓存静态资源"><a class="header" href="#7-缓存静态资源">7. 缓存静态资源</a></h2>
<p>添加过期时间以使得浏览器在过期时间内都使用缓存资源，另外在资源的URL中添加数据摘要(MD5)，当服务器资源更新时更新URL，
以使得浏览器加载新资源。</p>
<p>URL不能写死在页面中，比如要访问商品信息，可以通过访问商品接口得到要展示的商品图片的URL，每次
访问商品信息都会重新得到URL，那么图片更新的时候，就会得到新的URL，以使得浏览器重新加载资源。</p>
<p>小程序甚至iOS也是一样的思想，可以手动写缓存，保存资源数据和摘要，下一次访问接口比对摘要，有变化则更新缓存</p>
<h2 id="8-压缩文件"><a class="header" href="#8-压缩文件">8. 压缩文件</a></h2>
<p>Webpack压缩
JavaScript：UglifyPlugin
CSS ：MiniCssExtractPlugin
HTML：HtmlWebpackPlugin</p>
<h2 id="9-图片优化"><a class="header" href="#9-图片优化">9. 图片优化</a></h2>
<ol>
<li>图片延迟加载，只有当图片在可视区域才真正加载</li>
<li>根据屏幕大小自动加载合适的图片</li>
<li>使用WebP格式的图片</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swifter-swift必备tips"><a class="header" href="#swifter-swift必备tips">Swifter Swift必备Tips</a></h1>
<h2 id="1-柯里化"><a class="header" href="#1-柯里化">1. 柯里化</a></h2>
<pre><code class="language-swift">func addTo(_ adder: Int) -&gt; (Int) -&gt; Int {
    return { num in
        adder + num
    }
}

let addToOne = addTo(1)
let addToTwo = addTo(2)

print(addToOne(10)) // 11
print(addToTwo(10)) // 12
</code></pre>
<h2 id="2-sequence-for-in迭代"><a class="header" href="#2-sequence-for-in迭代">2. Sequence for-in迭代</a></h2>
<pre><code class="language-swift">struct IntArray: Sequence {
    var array: [Int]
    
    func makeIterator() -&gt; IntArrayIterator {
        return IntArrayIterator(array: array)
    }
}

struct IntArrayIterator: IteratorProtocol {
    var array: [Int]
    var index = 0
    
    mutating func next() -&gt; Int? {
        guard index &lt; array.count else { return nil }
        defer {
            index += 1
        }
        return array[index]
    }
}

let array = IntArray(array: [0, 1, 2, 3])
for item in array {
    print(item)
}
</code></pre>
<h2 id="3-元组多返回值"><a class="header" href="#3-元组多返回值">3. 元组多返回值</a></h2>
<pre><code class="language-swift">func getColor() -&gt; (R: Int, G: Int, B: Int) {
    return (255, 255, 255)
}

print(getColor()) // (R: 255, G: 255, B: 255)
</code></pre>
<h2 id="4-autoclosure-自动闭包"><a class="header" href="#4-autoclosure-自动闭包">4. @autoclosure 自动闭包</a></h2>
<pre><code class="language-swift">func closure(_ number: @autoclosure () -&gt; Int) -&gt; Int {
    let number = number()
    return number
}

print(closure(3)) // 3
</code></pre>
<h2 id="4-escaping-逃逸闭包"><a class="header" href="#4-escaping-逃逸闭包">4. @escaping 逃逸闭包</a></h2>
<pre><code class="language-swift">import Dispatch

func asyncAfter(seconds: Int, execute: @escaping () -&gt; Void) {
    DispatchQueue.main.asyncAfter(deadline: .now() + .seconds(seconds)) {
        execute()
    }
}

asyncAfter(seconds: 3) {
    print(&quot;3秒后执行&quot;)
}
</code></pre>
<h2 id="5-操作符重载"><a class="header" href="#5-操作符重载">5. 操作符重载</a></h2>
<pre><code class="language-swift">struct ValueInt {
    let value: Int
    
    static func +(left: ValueInt, right: ValueInt) -&gt; Int {
        left.value + right.value
    }
}

let a = ValueInt(value: 1)
let b = ValueInt(value: 3)

print(a + b) // 4
</code></pre>
<h2 id="6-函数参数传递"><a class="header" href="#6-函数参数传递">6. 函数参数传递</a></h2>
<ul>
<li>
<h3 id="值类型参数"><a class="header" href="#值类型参数">值类型参数</a></h3>
<h4 id="不更改原值"><a class="header" href="#不更改原值">不更改原值</a></h4>
<pre><code class="language-swift">func increased(_ variable: Int) -&gt; Int {
    var variable = variable
    variable += 1
    return variable
}

print(increased(0)) // 1
</code></pre>
<h4 id="更改原值"><a class="header" href="#更改原值">更改原值</a></h4>
<pre><code class="language-swift">func increase(_ variable: inout Int) {
    variable += 1
}

var variable = 0

increase(&amp;variable)

print(variable) // 1
</code></pre>
</li>
<li>
<h3 id="引用类型参数"><a class="header" href="#引用类型参数">引用类型参数</a></h3>
<h4 id="不更改原值-1"><a class="header" href="#不更改原值-1">不更改原值</a></h4>
<pre><code class="language-swift">class ReferenceInt {
    var value: Int
    init(_ value: Int) {
        self.value = value
    }
}

func increased(_ variable: ReferenceInt) -&gt; ReferenceInt {
    let variable = ReferenceInt(variable.value)
    variable.value += 1
    return variable
}

let variable = ReferenceInt(0)

print(increased(variable).value) // 1
print(variable.value) // 0
</code></pre>
<h4 id="更改原值-1"><a class="header" href="#更改原值-1">更改原值</a></h4>
<pre><code class="language-swift">func increase(_ variable: ReferenceInt) {
    variable.value += 1
}


let variable = ReferenceInt(0)
increase(variable)
print(variable.value)
</code></pre>
</li>
</ul>
<h2 id="7-字面量表达协议"><a class="header" href="#7-字面量表达协议">7. 字面量表达协议</a></h2>
<pre><code class="language-swift">struct ValueInt: ExpressibleByIntegerLiteral {
    var value: Int
    
    init(integerLiteral value: IntegerLiteralType) {
        self.value = value
    }
}

let variable: ValueInt = 3
print(variable.value) // 3
</code></pre>
<h2 id="8-subscript-下标访问"><a class="header" href="#8-subscript-下标访问">8. subscript 下标访问</a></h2>
<pre><code class="language-swift">struct IntArray {
    var array: [Int]

    subscript(index: Int) -&gt; Int {
        get {
            array[index]
        }
        set {
            array[index] = newValue
        }
    }
}

var array = IntArray(array: [0, 1, 2, 3])
print(array[1]) // 1
array[3] = 4
print(array[3]) // 4
</code></pre>
<h2 id="9-typealias-类型别名"><a class="header" href="#9-typealias-类型别名">9. typealias 类型别名</a></h2>
<pre><code class="language-swift">typealias IntArray = Array&lt;Int&gt;


protocol A {
    var a: Int { get }
}

protocol B {
    var b: Int { get }
}

typealias C = A &amp; B

struct D: C {
    var a: Int
    
    var b: Int
    
}
</code></pre>
<h2 id="10-associatedtype-相关类型"><a class="header" href="#10-associatedtype-相关类型">10. associatedType 相关类型</a></h2>
<pre><code class="language-swift">protocol ArrayExtension {
    associatedtype T
    
    mutating func appendAndPrint(_ newElement: T)
}

extension Array: ArrayExtension {
    typealias T = Element
    
    mutating func appendAndPrint(_ newElement: Element) {
        print(newElement)
        append(newElement)
    }
}

var array = Array&lt;Int&gt;()
array.appendAndPrint(1) // 1
</code></pre>
<h2 id="11-可变参数"><a class="header" href="#11-可变参数">11. 可变参数</a></h2>
<pre><code class="language-swift">func sum(_ number: Int...) -&gt; Int {
    return number.reduce(0, +)
}

print(sum(0, 1, 2, 3)) // 6
</code></pre>
<h2 id="12-初始化顺序"><a class="header" href="#12-初始化顺序">12. 初始化顺序</a></h2>
<pre><code class="language-swift">class Rectangle {
    var name: String
    init() {
        name = &quot;长方形&quot;
    }
}

class Square: Rectangle {
    var sideLength: Int
    override init() {
        sideLength = 10
        super.init()
        name = &quot;正方形&quot;
    }
}
</code></pre>
<h2 id="13-可空初始化"><a class="header" href="#13-可空初始化">13. 可空初始化</a></h2>
<pre><code class="language-swift">struct PositiveNumberString {
    var value: String
    init?(_ value: Int) {
        guard value &gt; 0 else { return nil }
        self.value = String(value)
    }
}

let str = PositiveNumberString(-1)
print(str as Any) // nil
</code></pre>
<h2 id="14-函数默认参数"><a class="header" href="#14-函数默认参数">14. 函数默认参数</a></h2>
<pre><code class="language-swift">func printInt(_ value: Int = 0) {
    print(value)
}

printInt() // 0
printInt(1) // 1
</code></pre>
<h2 id="15---区间操作符"><a class="header" href="#15---区间操作符">15. ... ..&lt; 区间操作符</a></h2>
<pre><code class="language-swift">let range = 0..&lt;3
let closedRange = 0...3

print([Int](range)) // [0, 1, 2]
print([Int](closedRange)) // [0, 1, 2, 3]

print((&quot;a&quot;...&quot;z&quot;).contains(&quot;c&quot;)) // true
</code></pre>
<h2 id="16-元类型"><a class="header" href="#16-元类型">16. 元类型</a></h2>
<pre><code class="language-swift">struct Type {
    static func staticMethod() {
        print(&quot;静态方法&quot;)
    }
    
    func instanceMethod() {
        print(&quot;实例方法&quot;)
    }
}

let instance: Type = Type()
instance.instanceMethod() // 实例方法
let type: Type.Type = Type.self
type.staticMethod() // 静态方法
</code></pre>
<h2 id="17-深拷贝"><a class="header" href="#17-深拷贝">17. 深拷贝</a></h2>
<pre><code class="language-swift">protocol Copyable {
    func copy() -&gt; Self
}

class ReferenceInt: Copyable {
    var value: Int
    
    required init(_ value: Int) {
        self.value = value
    }
    
    func copy() -&gt; Self {
        return type(of: self).init(value)
    }

}


let a = ReferenceInt(0)
let b = a.copy()
b.value = 1

print(a.value) // 0
print(b.value) // 1
</code></pre>
<h2 id="18-属性观察"><a class="header" href="#18-属性观察">18. 属性观察</a></h2>
<pre><code class="language-swift">struct ValueInt {
    var value: Int {
        willSet {
            print(&quot;值即将从\(value)更改为\(newValue)&quot;)
        }
        didSet {
            print(&quot;值已经从\(oldValue)更改为\(value)&quot;)
        }
    }
}

var variable = ValueInt(value: 0)
variable.value = 1 // 值即将从0更改为1 \n 值已经从0更改为1
</code></pre>
<h2 id="19-lazy-懒加载"><a class="header" href="#19-lazy-懒加载">19. lazy 懒加载</a></h2>
<pre><code class="language-swift">struct LazyMan {
    var food: String = {
        print(&quot;吃饭&quot;)
        return &quot;食物&quot;
    }()
    
    lazy var work: String = {
        print(&quot;起床&quot;)
        return &quot;工作&quot;
    }()
}

var man = LazyMan() // 吃饭
print(man.work) // 起床 \n 工作
</code></pre>
<h2 id="20-懒实现序列"><a class="header" href="#20-懒实现序列">20. 懒实现序列</a></h2>
<pre><code class="language-swift">let array = [0, 1, 2, 3]
let result = array.lazy.map { item -&gt; Int in
    print(&quot;正在映射\(item)&quot;)
    return item + 1
}

for item in result {
    print(&quot;映射结果\(item)&quot;)
    break
}

// 正在映射0
// 映射结果1
</code></pre>
<pre><code class="language-swift">let array = [0, 1, 2, 3]
let result = array.map { item -&gt; Int in
    print(&quot;正在映射\(item)&quot;)
    return item + 1
}

for item in result {
    print(&quot;映射结果\(item)&quot;)
    break
}

// 正在映射0
// 正在映射1
// 正在映射2
// 正在映射3
// 映射结果1
</code></pre>
<h2 id="21-optional-map"><a class="header" href="#21-optional-map">21. Optional Map</a></h2>
<pre><code class="language-swift">var variable: Int? = 0
let result = variable.map { variable in
    variable + 1
}

print(result as Any) // Optional(1)
</code></pre>
<pre><code class="language-swift">var variable: Int? = 0
var result: Int? = nil
if let variable = variable {
    result = variable + 1
}

print(result as Any) // Optional(1)
</code></pre>
<h2 id="22-where-模式匹配"><a class="header" href="#22-where-模式匹配">22. where 模式匹配</a></h2>
<pre><code class="language-swift">let model = &quot;iPhone12 mini&quot;

switch model {
case let model where model.hasPrefix(&quot;iPhone&quot;):
    print(&quot;iPhone&quot;)
default:
    break
}
// iPhone


for i in 0..&lt;10 where i &lt; 3 {
    print(i)
}
// 0 \n 1 \n 2
</code></pre>
<h2 id="23-indirect-嵌套enum"><a class="header" href="#23-indirect-嵌套enum">23. indirect 嵌套enum</a></h2>
<pre><code class="language-swift">indirect enum LinkedNode {
    case empty
    case node(Int, LinkedNode)
}

let linkedList = LinkedNode.node(0, .node(1, .node(2, .empty)))

print(linkedList) // node(0, node(1, .node(2, .empty)))
</code></pre>
<h2 id="24-实例方法的其它调用方式"><a class="header" href="#24-实例方法的其它调用方式">24. 实例方法的其它调用方式</a></h2>
<pre><code class="language-swift">struct ValueInt {
    let value: Int
    func call(_ way: String) {
        print(self.value, way)
    }
}

let v0 = ValueInt(value: 0)
v0.call(&quot;(value:)&quot;) // 0 (value:)
let v1 = ValueInt.init(value: 1)
v1.call(&quot;.init(value:)&quot;) // 1 .init(value:)

ValueInt.call(v0)(&quot;ValueInt.call(_ self:)&quot;) // 0 ValueInt.call(_ self:)

let call = ValueInt.call
call(v0)(&quot;call(_ self:)&quot;) // 0 call(_ self:)
</code></pre>
<h2 id="25-单例模式"><a class="header" href="#25-单例模式">25. 单例模式</a></h2>
<pre><code class="language-swift">struct Singleton {
    static let shared = Singleton()
    
}
</code></pre>
<h2 id="26-条件编译"><a class="header" href="#26-条件编译">26. 条件编译</a></h2>
<pre><code class="language-swift">#if os(iOS) || os(tvOS)
import UIKit
#elseif os(watchOS)
import WatchKit
#elseif os(macOS)
import AppKit
#endif
</code></pre>
<h2 id="27-注释标记"><a class="header" href="#27-注释标记">27. 注释标记</a></h2>
<pre><code class="language-swift">// MARK: - 分割线
// TODO: 待办
// FIXME: 待修复
</code></pre>
<h2 id="28-可选协议"><a class="header" href="#28-可选协议">28. 可选协议</a></h2>
<pre><code class="language-swift">import Foundation
// objc标记的协议只能被class类实现
@objc protocol OptionalProtocol {
    @objc optional func optionalMethod()
}
</code></pre>
<p>使用协议扩展来实现可选协议</p>
<pre><code class="language-swift">protocol OptionalProtocol {
    func optionalMethod()
}

extension OptionalProtocol {
    func optionalMethod() {
        
    }
}
</code></pre>
<h2 id="29-判断实例类型"><a class="header" href="#29-判断实例类型">29. 判断实例类型</a></h2>
<pre><code class="language-swift">print(type(of: 1)) // Int
print(1 is Int) // true
</code></pre>
<h2 id="30---判断相等"><a class="header" href="#30---判断相等">30. == === 判断相等</a></h2>
<pre><code class="language-swift">class ReferenceInt {
    var value: Int
    init(_ value: Int) {
        self.value = value
    }
    
    static func ==(left: ReferenceInt, right: ReferenceInt) -&gt; Bool {
        return left.value == right.value
    }
}

let a = ReferenceInt(0)
let b = ReferenceInt(0)
print(a == b) // true
print(a === b) // false
</code></pre>
<h2 id="31-格式化字符串"><a class="header" href="#31-格式化字符串">31. 格式化字符串</a></h2>
<pre><code class="language-swift">import Foundation
print(String(format: &quot;%.2f&quot;, 3.333333)) // 3.33
</code></pre>
<h2 id="32-optionset-操作集合"><a class="header" href="#32-optionset-操作集合">32. OptionSet 操作集合</a></h2>
<pre><code class="language-swift">struct Options: OptionSet {
    let rawValue: Int
    
    static let left = Options(rawValue: 1)
    static let top = Options(rawValue: 1 &lt;&lt; 1)
    static let right = Options(rawValue: 1 &lt;&lt; 2)
    static let bottom = Options(rawValue: 1 &lt;&lt; 3)
}

var option: Options = .left
print(option) // Options(rawValue: 1)
option = .top
print(option) // Options(rawValue: 2)
option = .right
print(option) // Options(rawValue: 4)
option = .bottom
print(option) // Options(rawValue: 8)
option = [.left, .top]
print(option) // Options(rawValue: 3)
option = [.left, .top, .right, .bottom]
print(option) // Options(rawValue: 15)
</code></pre>
<h2 id="33-enumerate-数组列举"><a class="header" href="#33-enumerate-数组列举">33. enumerate 数组列举</a></h2>
<pre><code class="language-swift">for (index, item) in (10..&lt;13).enumerated() {
    print(index, item)
}
// 0 10 \n 1 11 \n 2 12
</code></pre>
<h2 id="34-associated-object扩展存储属性"><a class="header" href="#34-associated-object扩展存储属性">34. Associated Object扩展存储属性</a></h2>
<pre><code class="language-swift">import ObjectiveC
// 只能为class类扩展
class IPhone {
    
}

private var key: Void?

extension IPhone {
    var storage: Int? {
        get {
            return objc_getAssociatedObject(self, &amp;key) as? Int
        }
        
        set {
            objc_setAssociatedObject(self, &amp;key, newValue, .OBJC_ASSOCIATION_RETAIN_NONATOMIC)
        }
    }
}

var iPhone = IPhone()
print(iPhone.storage as Any) // nil
iPhone.storage = 128
print(iPhone.storage as Any) // Optional(128)
</code></pre>
<h2 id="35-lock-锁"><a class="header" href="#35-lock-锁">35. Lock 锁</a></h2>
<pre><code class="language-swift">import Foundation

func synchronized(_ lock: AnyObject, execute: () -&gt; Void) {
    objc_sync_enter(lock)
    execute()
    objc_sync_exit(lock)
}

class SafeData {
    var data = 0
    
    func add(_ number: Int) {
        synchronized(self) {
            data += number
        }
    }
}

let safeData = SafeData()
for _ in 0..&lt;10000 {
    DispatchQueue.global().async {
        safeData.add(1)
    }
}

print(safeData.data) // 10000
</code></pre>
<h2 id="36-编译符号"><a class="header" href="#36-编译符号">36. 编译符号</a></h2>
<pre><code class="language-swift">#file // 符号所在文件路径
#line // 符号所在行号
#column // 符号所在列
#function // 符号所在方法名
</code></pre>
<h2 id="37-溢出操作符"><a class="header" href="#37-溢出操作符">37. 溢出操作符</a></h2>
<pre><code class="language-swift">var max = UInt.max
print(String(max, radix: 2))
// 1111111111111111111111111111111111111111111111111111111111111111
max = max &amp;+ 1
print(String(max, radix: 2)) // 0
</code></pre>
<h2 id="38-属性访问控制"><a class="header" href="#38-属性访问控制">38. 属性访问控制</a></h2>
<pre><code class="language-swift">private
fileprivate
internal
public
open
</code></pre>
<h2 id="39-swift解释执行"><a class="header" href="#39-swift解释执行">39. Swift解释执行</a></h2>
<pre><code class="language-swift">#!/usr/bin/env swift

print(&quot;hello&quot;)
</code></pre>
<h2 id="40-swiftc编译"><a class="header" href="#40-swiftc编译">40. swiftc编译</a></h2>
<pre><code class="language-shell">swiftc main.swift
</code></pre>
<h2 id="41-自定义打印输出"><a class="header" href="#41-自定义打印输出">41. 自定义打印输出</a></h2>
<pre><code class="language-swift">struct ValueInt: CustomStringConvertible {
    let value: Int
    
    var description: String {
        return &quot;这是一个自定义的描述\(value)&quot;
    }
}

print(ValueInt(value: 1)) // 这是一个自定义的描述1
</code></pre>
<h2 id="42-断言"><a class="header" href="#42-断言">42. 断言</a></h2>
<pre><code class="language-swift">// 断言只在Debug模式下有效
assert(1 == 1)
</code></pre>
<h2 id="43-错误退出"><a class="header" href="#43-错误退出">43. 错误退出</a></h2>
<pre><code class="language-swift">fatalError()
</code></pre>
<h2 id="44-指针操作"><a class="header" href="#44-指针操作">44. 指针操作</a></h2>
<pre><code class="language-swift">//#include &quot;stdio.h&quot;
//
//int main() {
//    int a[] = {0, 1, 2};
//    int *p = a;
//    *(p+2) = 3;
//    for(int i; i &lt; 3; i ++) {
//        printf(&quot;%d\n&quot;, a[i]);
//    }
//    // 0 \n 1 \n 3 \n
//    return 0;
//}

var array = [0, 1, 2]
let pointer = UnsafeMutableBufferPointer&lt;Int&gt;(start: &amp;array, count: array.count).baseAddress
pointer?.advanced(by: 2).pointee = 3
print(array) // [0, 1, 3]
</code></pre>
<h2 id="45-条件协议扩展"><a class="header" href="#45-条件协议扩展">45. 条件协议扩展</a></h2>
<pre><code class="language-swift">protocol NumberProtocol {
    
}

extension Int: NumberProtocol {}

extension NumberProtocol where Self == Int {
    func int() {
        print(&quot;只有Int类型才可以有此方法&quot;)
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="swift工具链"><a class="header" href="#swift工具链">Swift工具链</a></h1>
<h2 id="swiftc"><a class="header" href="#swiftc">swiftc</a></h2>
<ol>
<li>
<p>编译</p>
<p><code>swiftc main.swift -o main.out</code></p>
</li>
<li>
<p>输出语法树</p>
<p><code>swiftc -dump-ast main.swift</code></p>
</li>
<li>
<p>输出Swift Intermediate Language</p>
<p><code>swiftc -emit-sil main.swift</code></p>
</li>
<li>
<p>输出汇编</p>
<p><code>swiftc -emit-assembly main.swift</code></p>
</li>
<li>
<p>输出LLVM IR</p>
<p><code>swiftc -emit-ir main.swift</code></p>
</li>
</ol>
<h2 id="swift-package"><a class="header" href="#swift-package">swift package</a></h2>
<ol>
<li>
<p>初始化包</p>
<p><code>swift package init</code></p>
<ul>
<li>
<p>初始化可执行包</p>
<p><code>swift package init --type executable</code></p>
</li>
</ul>
</li>
<li>
<p>解析包依赖，并抓取</p>
<p><code>swift package resolve</code></p>
</li>
<li>
<p>展示包依赖图</p>
<p><code>swift package show-dependencies</code></p>
</li>
<li>
<p>更新包依赖</p>
<p><code>swift package update</code></p>
</li>
<li>
<p>重置缓存的依赖</p>
<p><code>swift package reset</code></p>
</li>
<li>
<p>生成Xcode项目</p>
<p><code>swift package generate-xcodeproj</code></p>
</li>
</ol>
<h2 id="swift-2"><a class="header" href="#swift-2">swift</a></h2>
<ol>
<li>
<p>编译</p>
<p><code>swift build</code></p>
<ul>
<li>
<p>编译发布版本</p>
<p><code>swift build -c release</code></p>
</li>
</ul>
</li>
<li>
<p>运行</p>
<p><code>swift run</code></p>
</li>
</ol>
<h2 id="xcode-select"><a class="header" href="#xcode-select">xcode-select</a></h2>
<ol>
<li>
<p>显示当前使用的Xcode</p>
<p><code>xcode-select -p</code></p>
</li>
<li>
<p>切换指定的Xcode，工具链也会随之一同切换</p>
<p><code>sudo xcode-select -s /Applications/Xcode13.0-beta/Xcode-beta.app/Contents/Developer</code></p>
</li>
</ol>
<h2 id="xcodebuild"><a class="header" href="#xcodebuild">xcodebuild</a></h2>
<ol>
<li>
<p>终端使用代理</p>
<p><code>export all_proxy=127.0.0.1:1087</code></p>
</li>
<li>
<p>Xcode通过系统Git拉取依赖</p>
<p><code>xcodebuild -resolvePackageDependencies -scmProvider system</code></p>
</li>
</ol>
<h2 id="xcode"><a class="header" href="#xcode">xcode</a></h2>
<ol>
<li>
<p>Xcode添加本地Swift Package(必须是git仓库)</p>
<p><code>file:///Users/&lt;username&gt;/Workspace/&lt;packagename&gt;/</code></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<h2 id="本地仓库"><a class="header" href="#本地仓库">本地仓库</a></h2>
<ul>
<li>
<h3 id="基础操作"><a class="header" href="#基础操作">基础操作</a></h3>
</li>
</ul>
<ol>
<li>
<p>初始化仓库</p>
<p><code>git init</code></p>
</li>
<li>
<p>添加新文件到暂存区</p>
<p><code>git add README.md</code></p>
</li>
<li>
<p>删除暂存区某文件</p>
<p><code>git rm --cache README.md</code></p>
</li>
<li>
<p>添加文件的更改到暂存区</p>
<p><code>git add README.md</code></p>
</li>
<li>
<p>恢复对暂存区文件的更改</p>
<p><code>git restore --staged README.md</code></p>
</li>
<li>
<p>从暂存区恢复工作区的文件更改</p>
<p><code>git restore README.md</code></p>
</li>
<li>
<p>将暂存区提交到本地仓库</p>
<p><code>git commit -m 'message'</code></p>
</li>
<li>
<p>重置本地仓库到指定版本，并将暂存区恢复为对应版本</p>
<p><code>git reset HEAD^</code></p>
</li>
<li>
<p>重提某个版本，将工作区恢复为某个版本之前的版本；并生成新的提交用于恢复远程仓库</p>
<p><code>git revert HEAD</code></p>
</li>
</ol>
<ul>
<li>
<h3 id="分支操作"><a class="header" href="#分支操作">分支操作</a></h3>
</li>
</ul>
<ol>
<li>
<p>添加分支</p>
<p><code>git branch develop</code></p>
</li>
<li>
<p>删除分支</p>
<p><code>git branch -d develop</code></p>
</li>
<li>
<p>重命名分支</p>
<p><code>git branch -M main</code></p>
</li>
<li>
<p>强行改变某分支指向指定版本</p>
<p><code>git branch -f develop HEAD^</code></p>
</li>
<li>
<p>切换分支，并检出本地仓库某分支文件内容到工作区</p>
<p><code>git checkout develop</code></p>
<p><code>git switch develop</code></p>
</li>
<li>
<p>添加并切换分支</p>
<p><code>git checkout -b develop</code></p>
<p><code>git switch -c develop</code></p>
</li>
<li>
<p>当前分支合并某分支</p>
<p><code>git merge develop</code></p>
</li>
<li>
<p>变基当前分支到指定分支
(建议此种方式合并分支)</p>
<p><code>git rebase develop</code></p>
</li>
<li>
<p>交互式变基，从某个版本起开始选择</p>
<p><code>git rebase -i HEAD~3</code></p>
</li>
<li>
<p>检出到某个版本，检出实际上就是改变HEAD的指向，检出到某分支，HEAD指向某分支；
检出到某个版本而不是分支，HEAD指向某个版本，进入HEAD与分支分离的模式</p>
<p><code>git checkout HEAD^</code></p>
</li>
</ol>
<h2 id="远程仓库"><a class="header" href="#远程仓库">远程仓库</a></h2>
<ol>
<li>
<p>克隆远程仓库到本地</p>
<p><code>git clone http://localhost:3000/ericliuhusky/test.git</code></p>
</li>
<li>
<p>推送本地仓库到远程仓库</p>
<p><code>git push</code></p>
</li>
<li>
<p>抓取远程仓库到本地的远程分支，并不与本地分支合并</p>
<p><code>git fetch</code></p>
</li>
<li>
<p>拉取远程仓库到本地并与本地分支合并 = <code>git fetch</code> + <code>git merge</code></p>
<p><code>git pull</code></p>
</li>
<li>
<p>拉取远程仓库到本地并变基本地分支到远程分支</p>
<p><code>git pull --rebase</code></p>
</li>
</ol>
<h2 id="查看信息"><a class="header" href="#查看信息">查看信息</a></h2>
<ol>
<li>
<p>查看有哪些分支</p>
<p><code>git branch</code></p>
</li>
<li>
<p>查看包括远程分支的所有分支</p>
<p><code>git branch -al</code></p>
</li>
<li>
<p>查看最近一次的提交记录以及最近一次提交相比上次提交的文件内容具体更改的不同</p>
<p><code>git show</code></p>
</li>
<li>
<p>查看工作区相比暂存区有哪些文件更改</p>
<p><code>git status</code></p>
</li>
<li>
<p>查看工作区相比暂存区的文件内容具体更改的不同</p>
<p><code>git diff</code></p>
</li>
<li>
<p>查看提交记录 
(同时显示出版本哈希值和HEAD以及分支指向)</p>
<p><code>git log</code></p>
</li>
<li>
<p>责查用户对文件的修改记录</p>
<p><code>git blame README.md</code></p>
</li>
<li>
<p>查看有哪些远程仓库</p>
<p><code>git remote</code></p>
</li>
<li>
<p>查看远程仓库的url地址</p>
<p><code>git remote get-url origin</code></p>
</li>
</ol>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<ol>
<li>
<p>设置提交用户信息</p>
<p><code>git config --global user.name 'ericliuhusky'</code></p>
<p><code>git config --global user.email 'ericliuhusky@qq.com'</code></p>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="docc"><a class="header" href="#docc">DocC</a></h1>
<p>DocC是Swift框架或包的文档编译器 (Documentation Compiler)。
文档标记语法 (Documentation Markup)基于Markdown，增加了特性如：标识符链接、术语定义列表、代码列表和旁注。
另可提供交互式指引。生成的文档不仅可以直接在Xcode文档窗口中查看，还可以托管在网站上。</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>Xcode 13+</li>
<li>Swift 5.5+</li>
</ul>
<hr />
<h2 id="使用源代码中的文档注释来构建简单文档"><a class="header" href="#使用源代码中的文档注释来构建简单文档">使用源代码中的文档注释来构建简单文档</a></h2>
<ol>
<li>
<p>为代码添加文档注释</p>
<p><kbd>Command</kbd>+<kbd>Option</kbd>+<kbd>/</kbd></p>
</li>
<li>
<p>文档编译</p>
<p>Product -&gt; Build Documentation</p>
<p><kbd>Ctrl</kbd>+<kbd>Shift</kbd>+<kbd>Command</kbd>+<kbd>D</kbd></p>
</li>
</ol>
<hr />
<h2 id="配置体验更丰富的文档"><a class="header" href="#配置体验更丰富的文档">配置体验更丰富的文档</a></h2>
<p>当你想要提供额外的内容（如：引导页、扩展页、文章、教程页、图片资源）时，使用文档目录 (Documentation Catalog)</p>
<p>文档目录是后缀名为&quot;.docc&quot;的文件夹，引导页、扩展页和文章都是Markdown文件，
它们的区别就在于页面标题不同，分别为目标名标识符链接、待扩展的绝对路径标识符链接、纯文本</p>
<p>引导页是整个文档的第一个页面，扩展页用来扩展由每个标识符的文档注释生成的文档。
项目内的每个目标都可以有自己的文档目录，编译生成的文档与目标一一对应。</p>
<h3 id="格式化文档内容"><a class="header" href="#格式化文档内容">格式化文档内容</a></h3>
<h4 id="markdown原生"><a class="header" href="#markdown原生"><a href="Tools/Markdown.html">Markdown原生</a></a></h4>
<h4 id="documentation-markup特性"><a class="header" href="#documentation-markup特性">Documentation Markup特性</a></h4>
<pre><code class="language-markdown">``标识符链接``
&lt;doc:文章链接&gt;
&lt;doc:/tutorials/教程链接&gt;

![图像描述](图像名称)
图像文件名：图像名称~dark@2x.png

- term 术语: 定义
&gt; Tip: 旁白
旁白类型：Note, Important, Warning, Tip, Experiment

代码块使用空格而不是Tab缩进
</code></pre>
<h3 id="文档页面结构"><a class="header" href="#文档页面结构">文档页面结构</a></h3>
<p>文章无需多言就是普通的Markdown。</p>
<p>引导页和扩展页都要有一个页面标题，引导页标题为目标名标识符链接，扩展页标题为待扩展文档的标识符链接。</p>
<p>紧跟着页面标题是摘要，如果不编写摘要，文档就会显示 &quot;No overview available.&quot;</p>
<p>Overview和Discussion都是可有可无的部分，可以换用其它的名字，Topics之上的部分是对页面的解释说明类似于文章非常自由。</p>
<p>Topics部分就是文档的层次结构了，如果不进行配置，就会使用默认的层次结构，按照protocol, struct, class等类型分类。配置之后可以使文档可以更好的按照逻辑来分类，拥有更易理解的层次结构。Topics的名字不可以随意更改，只能使用<code>Topics</code></p>
<pre><code class="language-markdown"># ``目标名/标识符链接``

摘要

## Overview概览

概览

## Discussion详述

详述

## Topics

### Group分组1

- ``标识符链接``

### Group分组2

- ``标识符链接``

</code></pre>
<h2 id="发布部署"><a class="header" href="#发布部署">发布部署</a></h2>
<p>在Xcode文档窗口中手动导出</p>
<p>xcodebuild docbuild -scheme SlothCreator -derivedDataPath ~/Desktop/SlothCreatorBuild</p>
<h2 id="swift-docc插件"><a class="header" href="#swift-docc插件">Swift-DocC插件</a></h2>
<p>Swift 5.6+</p>
<pre><code class="language-swift">dependencies: [
    .package(url: &quot;https://github.com/apple/swift-docc-plugin&quot;, from: &quot;1.0.0&quot;),
],
</code></pre>
<p><code>swift package generate-documentation</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gitmoji"><a class="header" href="#gitmoji">Gitmoji</a></h1>
<h2 id="常用操作"><a class="header" href="#常用操作">常用操作</a></h2>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>🎉</td><td><code>:tada:</code></td><td>初始化项目</td></tr>
<tr><td>✨</td><td><code>:sparkles:</code></td><td>引入新特性</td></tr>
<tr><td>💥</td><td><code>:boom:</code></td><td>引入重大变化</td></tr>
<tr><td>🔥</td><td><code>:fire:</code></td><td>删除代码或文件</td></tr>
<tr><td>🐛</td><td><code>:bug:</code></td><td>修复错误</td></tr>
<tr><td>🚑</td><td><code>:ambulance</code></td><td>关键修复</td></tr>
<tr><td>💄</td><td><code>:lipstick:</code></td><td>更改UI</td></tr>
<tr><td>🚚</td><td><code>:truck:</code></td><td>移动或重命名资源</td></tr>
<tr><td>🏗️</td><td><code>:building_construction:</code></td><td>更改架构</td></tr>
<tr><td>♻️</td><td><code>:recycle:</code></td><td>重构代码</td></tr>
<tr><td>🚧</td><td><code>:construction:</code></td><td>工作正在进行</td></tr>
</tbody></table>
<h2 id="代码质量"><a class="header" href="#代码质量">代码质量</a></h2>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>🎨</td><td><code>:art:</code></td><td>改进代码结构/格式</td></tr>
<tr><td>⚡️</td><td><code>:zap:</code></td><td>提升性能</td></tr>
<tr><td>💡</td><td><code>:bulb:</code></td><td>更改代码内的注释</td></tr>
<tr><td>🚨</td><td><code>:rotating_light:</code></td><td>修复编译/静态分析警告</td></tr>
<tr><td>🩹</td><td><code>:adhesive_bandage:</code></td><td>对非关键问题的简单修复</td></tr>
<tr><td>🔒</td><td><code>:lock:</code></td><td>修复安全问题</td></tr>
<tr><td>✏️</td><td><code>:pencil2:</code></td><td>修正拼写错误</td></tr>
<tr><td>💩</td><td><code>:poop:</code></td><td>待改进的糟糕代码</td></tr>
<tr><td>🗑️</td><td><code>:wastebasket:</code></td><td>弃用代码</td></tr>
<tr><td>⚰️</td><td><code>:coffin:</code></td><td>删除死代码</td></tr>
</tbody></table>
<h2 id="代码管理"><a class="header" href="#代码管理">代码管理</a></h2>
<h3 id="配置管理"><a class="header" href="#配置管理">配置管理</a></h3>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>🙈</td><td><code>:see_no_evil:</code></td><td>更改.gitignore文件</td></tr>
<tr><td>📝</td><td><code>:memo:</code></td><td>更改文档</td></tr>
<tr><td>📄</td><td><code>:page_facing_up:</code></td><td>更改证书</td></tr>
<tr><td>📸</td><td><code>:camera_flash:</code></td><td>更改截图</td></tr>
<tr><td>👥</td><td><code>:busts_in_silhouette:</code></td><td>更改贡献者</td></tr>
<tr><td>🔧</td><td><code>:wrench:</code></td><td>更改配置文件</td></tr>
<tr><td>🔨</td><td><code>:hammer:</code></td><td>更改开发脚本工具</td></tr>
<tr><td>📦️</td><td><code>:package:</code></td><td>更改已编译文件或包</td></tr>
</tbody></table>
<h3 id="依赖管理"><a class="header" href="#依赖管理">依赖管理</a></h3>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>➕</td><td><code>:heavy_plus_sign:</code></td><td>添加依赖</td></tr>
<tr><td>➖</td><td><code>:heavy_minus_sign:</code></td><td>删除依赖</td></tr>
<tr><td>⬆️</td><td><code>:arrow_up:</code></td><td>升级依赖</td></tr>
<tr><td>⬇️</td><td><code>:arrow_down:</code></td><td>降级依赖</td></tr>
<tr><td>📌</td><td><code>:pushpin:</code></td><td>指定依赖版本</td></tr>
</tbody></table>
<h3 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h3>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>⏪️</td><td><code>:rewind:</code></td><td>还原更改</td></tr>
<tr><td>🔀</td><td><code>:twisted_rightwards_arrows:</code></td><td>合并分支</td></tr>
<tr><td>🔖</td><td><code>:bookmark:</code></td><td>发布/版本标签</td></tr>
</tbody></table>
<h2 id="代码测试"><a class="header" href="#代码测试">代码测试</a></h2>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>✅</td><td><code>:white_check_mark:</code></td><td>更改测试用例或通过测试</td></tr>
<tr><td>🧪</td><td><code>:test_tube:</code></td><td>添加失败的测试</td></tr>
</tbody></table>
<h2 id="持续集成"><a class="header" href="#持续集成">持续集成</a></h2>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>👷</td><td><code>:construction_worker:</code></td><td>更改CI构建系统</td></tr>
<tr><td>💚</td><td><code>:green_heart:</code></td><td>修复持续集成构建</td></tr>
<tr><td>🚀</td><td><code>:rocket:</code></td><td>部署相关</td></tr>
</tbody></table>
<h2 id="用户体验"><a class="header" href="#用户体验">用户体验</a></h2>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>🚸</td><td><code>:children_crossing:</code></td><td>改善用户体验</td></tr>
<tr><td>💫</td><td><code>:dizzy:</code></td><td>更改动画和过渡</td></tr>
<tr><td>🌐</td><td><code>:globe_with_meridians:</code></td><td>国际化和本地化</td></tr>
<tr><td>♿️</td><td><code>:wheelchair:</code></td><td>提高非健全人可访问性</td></tr>
</tbody></table>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<table><thead><tr><th>表情</th><th>代码</th><th>含义</th></tr></thead><tbody>
<tr><td>📈</td><td><code>:chart_with_upwards_trend:</code></td><td>添加或更新分析或追踪代码</td></tr>
<tr><td>👽️</td><td><code>:alien:</code></td><td>由于外部API更改而更新代码</td></tr>
<tr><td>🍱</td><td><code>:bento:</code></td><td>添加或更新资源</td></tr>
<tr><td>🍻</td><td><code>:beers:</code></td><td>醉醺醺的写代码</td></tr>
<tr><td>💬</td><td><code>:speech_balloon:</code></td><td>添加或更新文本和文字</td></tr>
<tr><td>🗃️</td><td><code>:card_file_box:</code></td><td>数据库相关更改</td></tr>
<tr><td>🔊</td><td><code>:loud_sound:</code></td><td>添加或更新日志</td></tr>
<tr><td>🔇</td><td><code>:mute:</code></td><td>删除日志</td></tr>
<tr><td>📱</td><td><code>:iphone:</code></td><td>响应式设计的工作</td></tr>
<tr><td>🤡</td><td><code>:clown_face:</code></td><td>模拟数据</td></tr>
<tr><td>🥚</td><td><code>:egg:</code></td><td>添加或更新彩蛋</td></tr>
<tr><td>⚗️</td><td><code>:alembic:</code></td><td>实验</td></tr>
<tr><td>🔍️</td><td><code>:mag:</code></td><td>提升SEO</td></tr>
<tr><td>🏷️</td><td><code>:label:</code></td><td>添加或更新类型</td></tr>
<tr><td>🌱</td><td><code>:seedling:</code></td><td>添加或更新种子文件</td></tr>
<tr><td>🚩</td><td><code>:triangular_flag_on_post:</code></td><td>添加更新或删除功能标志</td></tr>
<tr><td>🥅</td><td><code>:goal_net:</code></td><td>捕获错误</td></tr>
<tr><td>🛂</td><td><code>:passport_control:</code></td><td>处理授权、角色、权限相关的代码</td></tr>
<tr><td>🧐</td><td><code>:monocle_face:</code></td><td>数据探索/检查</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="有用的网站"><a class="header" href="#有用的网站">有用的网站</a></h1>
<h2 id="计算机科学"><a class="header" href="#计算机科学">计算机科学</a></h2>
<ol>
<li><a href="https://visualgo.net/zh">算法可视化</a></li>
<li><a href="https://labuladong.github.io/algo/">labuladong的算法小抄</a></li>
<li><a href="https://books.halfrost.com/leetcode/">LeetCode Cookbook</a></li>
</ol>
<h2 id="ios"><a class="header" href="#ios">iOS</a></h2>
<ol>
<li><a href="https://swift.org/">Swift</a></li>
<li><a href="https://www.cnswift.org/">Swift中文文档</a></li>
<li><a href="https://developer.apple.com/">苹果开发者</a></li>
<li><a href="https://refactoringguru.cn/design-patterns/swift">Swift设计模式</a></li>
<li><a href="https://www.raywenderlich.com/ios/books">Raywenderlich-iOS书籍</a></li>
<li><a href="https://google.github.io/swift/">Google-Swift代码风格</a></li>
<li><a href="https://opensource.apple.com/">Apple开源</a></li>
<li><a href="https://awesome-tips.gitbook.io/ios/">awesome-tips</a></li>
<li><a href="https://swiftpackageindex.com/">SPM索引</a></li>
</ol>
<h2 id="工具"><a class="header" href="#工具">工具</a></h2>
<ol>
<li><a href="https://carbon.now.sh/">代码生成图片</a></li>
<li><a href="https://www.nomnoml.com/">UML图</a></li>
<li><a href="https://markmap.js.org/repl/">Markdown思维导图</a></li>
<li><a href="https://httpbin.org/">http模拟数据</a></li>
<li><a href="https://shields.io/">README徽章</a></li>
<li><a href="https://www.screensizes.app/">iOS屏幕尺寸</a></li>
</ol>
<h2 id="书籍"><a class="header" href="#书籍">书籍</a></h2>
<ol>
<li><a href="https://weiyinfu.cn/MaoZeDongAnthology/">毛泽东选集</a></li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mdbook"><a class="header" href="#mdbook">mdbook</a></h1>
<h2 id="环境依赖"><a class="header" href="#环境依赖">环境依赖</a></h2>
<ul>
<li><a href="https://www.rust-lang.org/">Rust</a></li>
</ul>
<h2 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h2>
<ol>
<li>安装mdbook <code>cargo install mdbook</code></li>
<li>创建book <code>mdbook init my-book</code></li>
<li>热重载预览 <code>mdbook serve --open</code></li>
</ol>
<h2 id="配置目录"><a class="header" href="#配置目录">配置目录</a></h2>
<pre><code class="language-markdown">[前缀章节](relative/path/to/markdown.md)

# 分割标题

- [第一个编号章节](relative/path/to/markdown.md)
- [第二个编号章节](relative/path/to/markdown2.md)
   - [子编号章节](relative/path/to/markdown3.md)

---

- [草稿章节]()

[后缀章节](relative/path/to/markdown2.md)
</code></pre>
<h2 id="持续部署"><a class="header" href="#持续部署">持续部署</a></h2>
<pre><code class="language-sh">curl -sSL https://github.com/rust-lang/mdBook/releases/download/v0.4.18/mdbook-v0.4.18-x86_64-unknown-linux-gnu.tar.gz | tar -xz
./mdbook build
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vuepress"><a class="header" href="#vuepress">Vuepress</a></h1>
<h2 id="准备"><a class="header" href="#准备">准备</a></h2>
<h3 id="环境依赖-1"><a class="header" href="#环境依赖-1">环境依赖</a></h3>
<ul>
<li><a href="https://nodejs.org/en/">Node.js 12+</a></li>
<li><a href="https://classic.yarnpkg.com/en/docs/install#mac-stable">Yarn 1</a></li>
</ul>
<h3 id="目录结构"><a class="header" href="#目录结构">目录结构</a></h3>
<pre><code>├─ docs
│  ├─ .vuepress
│  │  ├─ .cache
│  │  ├─ .temp
│  │  ├─ public
│  │  │  └─ images
│  │  │  │  └─ logo.png
│  │  └─ config.js
│  └─ README.md
├─ node_modules
├─ .gitignore
├─ package.json
└─ yarn.lock
</code></pre>
<h3 id="gitignore配置"><a class="header" href="#gitignore配置"><code>.gitignore</code>配置</a></h3>
<pre><code>.DS_Store
node_modules/
dist/
.cache
.temp
</code></pre>
<h3 id="packagejson配置"><a class="header" href="#packagejson配置"><code>package.json</code>配置</a></h3>
<pre><code class="language-json">&quot;scripts&quot;: {
    &quot;docs:dev&quot;: &quot;vuepress dev docs&quot;,
    &quot;docs:build&quot;: &quot;vuepress build docs&quot;
}
</code></pre>
<h2 id="快速开始-1"><a class="header" href="#快速开始-1">快速开始</a></h2>
<h3 id="1-初始化"><a class="header" href="#1-初始化">1. 初始化</a></h3>
<pre><code class="language-shell">yarn init
</code></pre>
<h3 id="2-添加vuepress依赖"><a class="header" href="#2-添加vuepress依赖">2. 添加Vuepress依赖</a></h3>
<pre><code class="language-shell">yarn add vuepress
</code></pre>
<h3 id="3-热重载预览"><a class="header" href="#3-热重载预览">3. 热重载预览</a></h3>
<pre><code class="language-shell">yarn docs:dev
</code></pre>
<h2 id="markdown扩展"><a class="header" href="#markdown扩展">Markdown扩展</a></h2>
<h4 id="markdown原生-1"><a class="header" href="#markdown原生-1"><a href="Tools/Markdown.html">Markdown原生</a></a></h4>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<pre><code class="language-markdown">[[toc]]
</code></pre>
<h3 id="代码块高亮"><a class="header" href="#代码块高亮">代码块高亮</a></h3>
<p><code>swift{1,3,5-6}</code></p>
<pre><code class="language-swift{1 3 5-6}">1
2
3
4
5
6
</code></pre>
<h3 id="导入代码"><a class="header" href="#导入代码">导入代码</a></h3>
<p><code>@[code swift]()</code></p>
<p>@<a href="Tools/../.vuepress/config.js">code{1-3}</a></p>
<h3 id="vue组件"><a class="header" href="#vue组件">Vue组件</a></h3>
<p><code>&lt;Badge text=&quot;徽标&quot;/&gt;</code></p>
<Badge text="徽标"/>
<h2 id="配置-1"><a class="header" href="#配置-1">配置</a></h2>
<p><code>.vuepress/congig.js</code></p>
<pre><code class="language-javascript">module.exports = {

  title: '网站标题',
  head: [['link', { rel: 'icon', href: '/images/logo.png' }]]

}
</code></pre>
<h3 id="导航栏"><a class="header" href="#导航栏">导航栏</a></h3>
<pre><code class="language-javascript">module.exports = {

  themeConfig: {

    navbar: [
      { text: '导航', link: '/目录/' },
      { text: '下拉列表导航', children: ['文件地址', '文件地址'] }
    ]

  }

}
</code></pre>
<h3 id="侧边栏"><a class="header" href="#侧边栏">侧边栏</a></h3>
<pre><code class="language-javascript">module.exports = {

  themeConfig: {

    sidebar: {
      
      '/目录/': [
        {
          text: '侧边栏',
          children: ['文件地址', '文件地址']
        },
        {
          text: '侧边栏',
          children: ['文件地址', '文件地址']
        }
      ]

    }

  }

}
</code></pre>
<h3 id="404页面"><a class="header" href="#404页面">404页面</a></h3>
<pre><code class="language-javascript">module.exports = {

  themeConfig: {
    notFound: ['404页面提示信息', '来到了没有知识的荒原'],
    backToHome: '返回首页'
  }

}
</code></pre>
<h2 id="部署"><a class="header" href="#部署">部署</a></h2>
<h3 id="1-配置base"><a class="header" href="#1-配置base">1. 配置base</a></h3>
<p>发布地址:<code>https://&lt;USERNAME&gt;.github.io/&lt;REPONAME&gt;</code></p>
<p>设置<code>base</code>为<code>/&lt;REPONAME&gt;/</code></p>
<h3 id="2-配置工作流"><a class="header" href="#2-配置工作流">2. 配置工作流</a></h3>
<p><code>.github/workflows/doc.yml</code></p>
<pre><code class="language-yml">name: Deploy Website CI

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v2

      - name: Build
        run: |
          yarn install
          yarn docs:build
      - name: Deploy
        uses: JamesIves/github-pages-deploy-action@4.1.1
        with:
          branch: gh-pages
          folder: docs/.vuepress/dist
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="markdown"><a class="header" href="#markdown">Markdown</a></h1>
<h2 id="标题"><a class="header" href="#标题">标题</a></h2>
<pre><code class="language-markdown"># 一级标题
## 二级标题
### 三级标题
</code></pre>
<h1 id="一级标题"><a class="header" href="#一级标题">一级标题</a></h1>
<h2 id="二级标题"><a class="header" href="#二级标题">二级标题</a></h2>
<h3 id="三级标题"><a class="header" href="#三级标题">三级标题</a></h3>
<h2 id="文本"><a class="header" href="#文本">文本</a></h2>
<pre><code class="language-markdown">普通文本
**粗体**
*斜体*
~~删除~~
</code></pre>
<p>普通文本
<strong>粗体</strong>
<em>斜体</em>
<del>删除</del></p>
<h2 id="列表"><a class="header" href="#列表">列表</a></h2>
<pre><code class="language-markdown">- 无序列表
1. 有序列表
</code></pre>
<ul>
<li>无序列表</li>
</ul>
<ol>
<li>有序列表</li>
</ol>
<h2 id="代码"><a class="header" href="#代码">代码</a></h2>
<pre><code class="language-markdown">`单行代码`
\```
代码块
\```
</code></pre>
<p><code>单行代码</code></p>
<pre><code>代码块
</code></pre>
<h2 id="链接与图像"><a class="header" href="#链接与图像">链接与图像</a></h2>
<pre><code class="language-markdown">[链接](URL)
![图像](URL)
</code></pre>
<p><a href="Tools/URL">链接</a>
<img src="Tools/URL" alt="图像" /></p>
<h2 id="表格"><a class="header" href="#表格">表格</a></h2>
<pre><code class="language-markdown">表头 |
--- |
单元格 |
</code></pre>
<table><thead><tr><th>表头</th></tr></thead><tbody>
<tr><td>单元格</td></tr>
</tbody></table>
<h2 id="分割线"><a class="header" href="#分割线">分割线</a></h2>
<pre><code class="language-markdown">---
</code></pre>
<hr />
<h2 id="缩进"><a class="header" href="#缩进">缩进</a></h2>
<pre><code class="language-markdown">&gt;一级缩进
&gt;&gt;二级缩进
&gt;&gt;&gt;三级缩进
</code></pre>
<blockquote>
<p>一级缩进
&gt;二级缩进
&gt;&gt;三级缩进</p>
</blockquote>
<h2 id="换行"><a class="header" href="#换行">换行</a></h2>
<ol>
<li>结尾空两格</li>
<li>中间空一行</li>
</ol>
<pre><code class="language-markdown">第一行  
第二行

第一行

第二行
</code></pre>
<p>第一行<br />
第二行</p>
<p>第一行</p>
<p>第二行</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
